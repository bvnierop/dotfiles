#+TITLE: Emacs configuration file
#+AUTHOR: Bart van Nierop

* Config
** TODOS
*** TODO Bindings
https://github.com/magit/magit/issues/1968
*** TODO Run through Vim config
**** TODO plugins
***** DONE Commentary
***** DONE Dispatch (not needed)
***** DONE Surround
***** DONE Sleuth (could be solved with local configs)
See: dtrt-indent
***** DONE CtrlP (Helm / Projectile)
***** TODO YouCompleteMe (autocompletion / company + providers)
***** TODO Search (ack/ag)
***** TODO Fugitive (Magit)
***** TODO Slimv (Slime)
***** TODO Jsx
***** TODO Ragtag (html editing)
***** TODO Ale (flycheck?)
***** TODO Tmux
*** TODO Open special windows in a normal place
*** TODO Autocomplete
*** TODO Indent size, spaces, etc.
*** TODO Layout management / tmux / screen
*** TODO Language support
*** TODO Magit
*** TODO Hydra
https://github.com/abo-abo/hydra
*** TODO Line width
*** TODO Helm open buffer with <RET>?
*** TODO Company don't complete with <RET>
** Utility functions
*** Lexical binding
Since Emacs 24, Emacs Lisp supports lexical binding. Since this makes lisp much
more powerful, we enable it.
#+BEGIN_SRC emacs-lisp
(setq lexical-binding t)
#+END_SRC
*** List helpers
#+BEGIN_SRC emacs-lisp
(defun bvn/add-to-list (target-list val &rest values)
  (while val
    (add-to-list target-list val)
    (setq val (pop values))))
#+END_SRC
*** Function helpers
The function below helps us find functions that have a certain suffix
as name. The goal is to support dynamic configuration of plugins.
#+BEGIN_SRC emacs-lisp
(defun find-functions-with-suffix (suffix)
  (let ((functions nil))
    (mapatoms (lambda (a)
                (when (and (fboundp a)
                           (string-suffix-p suffix (symbol-name a)))
                  (push a functions))))
    functions))
#+END_SRC
It is used like this:
(defun foobarbaz-config ()
  (mapc 'funcall
        (functions-with-suffix "/foobarbaz-config")))

(defun ruby/foobarbaz-config ()
  (interactive)
  (message "called!"))
*** OS helpers
The following macros only execute their body on the given operating system.
#+BEGIN_SRC emacs-lisp
(defmacro bvn/on-windows (&rest body)
  `(if (eq system-type 'windows-nt)
     (progn ,@body)))
#+END_SRC

** Basic configuration
*** Setting up the package manager
Note: For this to work on windows, gnutls needs to be installed. Binaries can be
gotten from https://www.gnutls.org/download.html and can be unpacked into the emacs root
folder (so that .../bin and .../lib match).
#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)

(setq package-enable-at-startup nil)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+END_SRC

For configuring the packages, we have a few helpers. This allows us to
create language specific functions for configuring packages.

Instead of `use_package`, we can use `bvn/use-packages` throughout the
config. Duplicates don't matter. At the end of the config, we put
`bvn/load-packages` which actually loads and uses the packages.

Package `init` and `config` functions can be defined semantically:
`prefix/package-init` and `prefix/package-config`.
#+BEGIN_SRC emacs-lisp
(defvar bvn/packages ())

(defmacro bvn/use-packages (package-name &rest package-names)
  `(let ((package-name ',package-name)
         (package-names ',package-names))
     (while package-name
       (push package-name bvn/packages)
       (setq package-name (pop package-names)))))

(defmacro bvn/load-packages ()
  (delete-dups bvn/packages)
  `(progn
     ,@(mapcar 'bvn/load-packages--use-block bvn/packages)
     (setq bvn/packages nil)))

(defun bvn/load-packages--use-block (package)
  (let ((mode (bvn/load-packages--collect-configuration-fns package "mode")))
    `(use-package ,package
       :ensure t
       :mode ,mode
       :init (bvn/load-packages--call-configuration-fns ',package "init")
       :config (bvn/load-packages--call-configuration-fns ',package "config"))))

(defun bvn/load-packages--call-configuration-fns (package-name action)
  (mapcar 'funcall
        (find-functions-with-suffix (concat "/" (symbol-name package-name) "-" action))))

(defun bvn/load-packages--collect-configuration-fns (package-name action)
  (apply 'append
         (mapcar 'funcall
                 (find-functions-with-suffix (concat "/" (symbol-name package-name) "-" action)))))
#+END_SRC
*** Evil
It is said that Emacs is an awesome operating system, lacking only a decent text
editor. [[https://github.com/emacs-evil/evil][Evil-mode]] changes that, bringing modal editing to Emacs.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init (setq evil-want-C-u-scroll t)
  :config (evil-mode t))
#+END_SRC
**** Keybinding helpers
We like Vim style keybindings. These functions help.
#+BEGIN_SRC emacs-lisp
(defun kbd-or-fn (input)
  "Return the keyboard encoded sequence if input is a string. Otherwise, return the input, assuming it's a function."
  (if (stringp input)
      (kbd input)
    input))

(defun gmap (keys action)
  "Map keys to an action using `global-set-key`."
  (global-set-key (kbd keys) (kbd-or-fn action)))

(defun fmap (keybind-fn keys action)
  "Map keys to an action using `keybind-fn`."
  (call keybind-fn (kbd keys) (kbd-or-fn action)))

(defun xmap (keymap keys action &rest bindings)
  "Map keys to an action in the given `keymap`."
  (while keys
    (define-key keymap (kbd keys) (kbd-or-fn action))
    (setq keys (pop bindings)
          action (pop bindings))))

(defun nmap (keys action &rest bindings)
  "Map keys to an action in normal mode."
   (apply 'xmap evil-normal-state-map keys action bindings))

(defun imap (keys action &rest bindings)
  "Map keys to an action in insert mode."
   (apply 'xmap evil-insert-state-map keys action bindings))

(defun vmap (keys action &rest bindings)
  "Map keys to an action in visual mode."
   (apply 'xmap evil-visual-state-map keys action bindings))

(defun mmap (keys action &rest bindings)
  "Map keys to an action in motion mode."
   (apply 'xmap evil-motion-state-map keys action bindings))
#+END_SRC

For many things in the minibuffer we like to change the behaviour of C-w and
C-r. This macro helps.
#+BEGIN_SRC emacs-lisp
(defmacro bvn/vimify-minibuffer (mode)
  `(xmap ,mode
         "C-w" 'evil-delete-backward-word
         "C-r" 'evil-paste-from-register))
#+END_SRC

**** Cleaning some keys
Don't bind anything to backslash, space or comma. Yes, comma is something in Vim, but
I never use it, and do use it for my leader key.
#+BEGIN_SRC emacs-lisp
(nmap "\\" nil)
(vmap "\\" nil)
(mmap "\\" nil)

(nmap "," nil)
(vmap "," nil)
(mmap "," nil)

(nmap "SPC" nil)
(vmap "SPC" nil)
(mmap "SPC" nil)
#+END_SRC
**** Command aliases
Ex commands are better when they're short
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "sus" 'suspend-emacs)
#+END_SRC
**** Cursor movement
In Vim I've made some changes to the way j and k work. I want them to move over
visual lines, not actual ones.
#+BEGIN_SRC emacs-lisp
(nmap "j" 'evil-next-visual-line
      "k" 'evil-previous-visual-line)

(vmap "j" 'evil-next-visual-line
      "k" 'evil-previous-visual-line)

(mmap "j" 'evil-next-visual-line
      "k" 'evil-previous-visual-line)
#+END_SRC
Another change I've made in Vim is that C-u and C-d simply move the cursor, and
not the screen. This makes them usefull to jump a sizable distance, making it
easy to navigate a file. It's not truly the Vim way, but works just fine for me.
#+BEGIN_SRC emacs-lisp
(nmap "C-u" "20k"
      "C-d" "20j")

(vmap "C-u" "20k"
      "C-d" "20j")

(mmap "C-u" "20k"
      "C-d" "20j")
#+END_SRC
Because C-u is actually quite important in Emacs, we need to remap it.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-C-U") 'universal-argument)
#+END_SRC

**** Commentary
Having an easy way to comment out lines is pretty awesome.
#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :ensure t
  :config (setq evil-commentary-mode t))
  
#+END_SRC
**** Surround
Vim-surround is one of Tim Pope's more useful plugins. And that says something.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :config (global-evil-surround-mode 1))
#+END_SRC

** Vimify
Some things, we really want just like in vim...
#+BEGIN_SRC emacs-lisp
(gmap "C-w" 'evil-delete-backward-word)
(gmap "C-r" 'evil-paste-from-register)
#+END_SRC
** Basic configuration
*** Color scheme
Gruvbox is the best color scheme, hands down.
#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :ensure t
  :config
  (load-theme 'gruvbox t))
#+END_SRC
*** Various quality of life settings
Show matching parentheses.
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode 1)
#+END_SRC

Use line numbers.
#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
#+END_SRC

Show column numbers in the mode line
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

No cursor blinking
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

Indentation.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
(setq tab-stop-list (number-sequence tab-width 200 tab-width))
#+END_SRC

Use UTF-8 as the default file encoding.
#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

Automatically reload files changed files.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

Highlight the current line.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
 
Store backups in a more central place.
#+BEGIN_SRC emacs-lisp
(defun bvn/generate-backup-file-name (file-path)
  "Generate and return a better file path for backups"
  (let* ((backup-root-dir "~/.emacs.d/tmp/")
         (sanitized-file-path (replace-regexp-in-string
                               "\\\\" "/" (replace-regexp-in-string
                                         "^\\([A-Za-z]\\):" "\\1/" file-path)))
         (full-file-path (replace-regexp-in-string
                          "//" "/" (concat backup-root-dir sanitized-file-path "~"))))
    (make-directory
     (file-name-directory full-file-path)
     (file-name-directory full-file-path))
    full-file-path))

(setq make-backup-file-name-function 'bvn/generate-backup-file-name
      backup-by-copying t)
#+END_SRC

Do not create lock files.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

Keep some space when scrolling. Also, scrolling 1 row or column at a time is nicer.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 8)
(setq scroll-step 1)
(setq hscroll-margin 16)
(setq hscroll-step 1)
#+END_SRC

Disable GUI fluff.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
*** Automatically detect indent settings
dtrt-indent is like vim-sleuth, but for Emacs. It detects the indent settings of the current file.
Apparently, it's not on melpa-stable.
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
  :config
  (setq dtrt-indent-mode t))
#+END_SRC
*** Helm
#+BEGIN_SRC emacs-lisp
(bvn/use-packages helm)

(defun helm/helm-config ()
  (helm-mode t)
  (setq helm-autoresize-mode t)
  (gmap  "M-x" 'helm-M-x)
  (bvn/vimify-minibuffer helm-map)
  (nmap ",fm" 'helm-mini))
#+END_SRC

*** Free keys
#+BEGIN_SRC emacs-lisp
(use-package free-keys
  :ensure t)
#+END_SRC
** Window layout
#+BEGIN_SRC emacs-lisp
(use-package popwin
  :ensure t)
#+END_SRC
** File navigation
Projectile is the package we use to deal with projects. We use helm-projectile to
integrate with helm.

Some things are best left alone. Therefore we ignore a bunch of files when searching with Projectile.
#+BEGIN_SRC emacs-lisp
  (bvn/use-packages projectile helm-projectile)

  (defun projectile/projectile-config ()
    (projectile-mode t))

  (defun helm-projectile/helm-projectile-config ()
    (nmap ",ff" 'helm-projectile-find-file
         ",fp" 'helm-projectile-switch-project)
    (mmap ",ff" 'helm-projectile-find-file
         ",fp" 'helm-projectile-switch-project)

    (bvn/add-to-list 'projectile-globally-ignored-directories
      ".git" ".hg" ".svn"
      ".yardoc"
      "public/images" "public/system" "data" "log" "tmp" "debug" "release"
      "node_modules" "vendor")

    (bvn/add-to-list 'projectile-globally-ignored-file-suffixes
      ".exe" ".so" ".a" ".d" ".dll" ".o" ".fasl"
      ".log" ".tlog"
      ".dat"
      ".sdf" 
      ".pdf"
      ".bcmap"
      ".png" ".jpg" ".jpeg" ".svg"))
#+END_SRC

One thing I did in vim was map switching between two buffers to \\
#+BEGIN_SRC emacs-lisp
(nmap "\\\\" 'evil-switch-to-windows-last-buffer)
(mmap "\\\\" 'evil-switch-to-windows-last-buffer)
#+END_SRC

** Search

** Source control
#+BEGIN_SRC emacs-lisp
(bvn/use-packages magit)

(defun magit/magit-config ()
  (nmap ",gs" 'magit-status
        ",gb" 'magit-blame
        ",gS" 'magit-stage-file
        ",gU" 'magit-unstage-file
        ",gl" 'magit-log
        ",gr" 'magit-rebase
        ",gd" 'magit-diff))
#+END_SRC

** Language support
*** TODO General
**** Auto completion
The common auto-complete front-end to Emacs is company-mode. Because company uses C-w
for 'show-location', and I want to use it to kill the previous word, the binding is removed.
It's bound to C-l instead.
#+BEGIN_SRC emacs-lisp
(bvn/use-packages company)
(defun company/company-config ()
  (xmap company-active-map
        "C-w" nil
        "C-l" 'company-show-location
        "C-n" 'company-select-next
        "C-p" 'company-select-previous
        "TAB" 'company-complete-common-or-cycle
        "ESC" 'company-abort)
  (global-company-mode))
#+END_SRC

We're going to be using different completion engines for different
languages. Each of these will be set up individually in their
languages heading.
**** Syntax checking
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)
#+END_SRC
*** TODO C#
*** TODO C++
*** TODO Common Lisp
*** TODO CSS
*** TODO HTML
*** TODO Java
*** TODO Javascript
*** TODO Markdown
#+BEGIN_SRC emacs-lisp
(bvn/use-packages markdown-mode)

(defun markdown/markdown-mode-mode ()
  '(("\\.md" . markdown-mode)
    ("\\.markdown" . markdown-mode)))

(defun markdown-mode-hook/configure ()
  (setq fill-column 80)
  (auto-fill-mode t))

(add-hook 'markdown-mode-hook 'markdown-mode-hook/configure)
#+END_SRC
*** TODO Python
**** Language support
On Windows, we're likely to use the Python version chooser 'py'.
#+BEGIN_SRC emacs-lisp
(bvn/on-windows
  (setq python-shell-interpreter "py"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bvn/use-packages anaconda-mode)

(defun python/anaconda-mode-config ()
  (add-hook 'python-mode-hook 'anaconda-mode))
#+END_SRC
**** Auto completion
#+BEGIN_SRC emacs-lisp
(bvn/use-packages company-anaconda)

(defun python/add-to-company ()
  (add-to-list 'company-backends 'company-anaconda))
(add-hook 'python-mode-hook 'python/add-to-company)
#+END_SRC
**** Syntax checking
*** TODO Ruby
** Software support
*** TODO Org mode
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)

(defun bvn/org-mode-hook ()
  (setq fill-column 80)
  (auto-fill-mode t))

(add-hook 'org-mode-hook 'bvn/org-mode-hook)
#+END_SRC
**** Keybindings
Evil has some keybindings that conflict with org mode. Fix them.
#+BEGIN_SRC emacs-lisp
(defun bvn/org-mode-bindings ()
  (nmap "TAB" 'org-cycle))
(add-hook 'org-mode-hook 'bvn/org-mode-bindings)
#+END_SRC
** Everything so far, which isn't a lot
#+BEGIN_SRC emacs-lisp
(nmap ",ll" 'eval-last-sexp)
#+END_SRC
*** Move custom to its own file
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'noerror)
#+END_SRC
*** Syntax highlighting in org code blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC
** Load packages
#+BEGIN_SRC emacs-lisp
(bvn/load-packages)
#+END_SRC
