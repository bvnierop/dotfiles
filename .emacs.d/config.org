#+TITLE: Emacs configuration file
#+AUTHOR: Bart van Nierop

* Config
** TODOS
*** TODO REWRITE TO STRAIGHT
**** Ensure EVIL is always available (so we don't have to use-feature evil all the time)
**** Ensure General is always available
*** TODO Bindings
https://github.com/magit/magit/issues/1968
*** TODO Run through Vim config
**** TODO plugins
***** DONE Commentary
***** DONE Dispatch (not needed)
***** DONE Surround
***** DONE Sleuth (could be solved with local configs)
See: dtrt-indent
***** DONE CtrlP (Helm / Projectile)
***** TODO YouCompleteMe (autocompletion / company + providers)
***** TODO Search (ack/ag)
***** TODO Fugitive (Magit)
***** TODO Slimv (Slime)
***** TODO Jsx
***** TODO Ragtag (html editing)
***** TODO Ale (flycheck?)
***** TODO Tmux
*** TODO Open special windows in a normal place
*** TODO Autocomplete
**** TODO Set proper backends everywhere (not _just_ for the language, also for filenames etc)
*** TODO Indent size, spaces, etc.
*** TODO Layout management / tmux / screen
*** TODO Language support
*** TODO Magit
*** TODO Hydra
https://github.com/abo-abo/hydra
*** TODO Line width
*** TODO Helm open buffer with <RET>?
*** TODO Company don't complete with <RET>
*** TODO Open/find file under cursor (ffap)
*** TODO Random stuff
**** Don't generate *scratch* instructions
** Utility functions
*** Lexical binding
Since Emacs 24, Emacs Lisp supports lexical binding. Since this makes lisp much
more powerful, we enable it.
#+BEGIN_SRC emacs-lisp
(setq lexical-binding t)
#+END_SRC
*** List helpers
#+BEGIN_SRC emacs-lisp
(defun bvn/add-to-list (target-list val &rest values)
  (while val
    (add-to-list target-list val)
    (setq val (pop values))))
#+END_SRC
*** Function helpers
The function below helps us find functions that have a certain suffix
as name. The goal is to support dynamic configuration of plugins.
#+BEGIN_SRC emacs-lisp
(defun find-functions-with-suffix (suffix)
  (let ((functions nil))
    (mapatoms (lambda (a)
                (when (and (fboundp a)
                           (string-suffix-p suffix (symbol-name a)))
                  (push a functions))))
    functions))
#+END_SRC
It is used like this:
(defun foobarbaz-config ()
  (mapc 'funcall
        (functions-with-suffix "/foobarbaz-config")))

(defun ruby/foobarbaz-config ()
  (interactive)
  (message "called!"))
*** OS helpers
The following macros only execute their body on the given operating system.
#+BEGIN_SRC emacs-lisp
(defmacro bvn/on-windows (&rest body)
  `(if (eq system-type 'windows-nt)
     (progn ,@body)))

(defmacro bvn/on-terminal (&rest body)
  `(unless window-system
     (progn ,@body)))

(defmacro bvn/on-gui (&rest body)
  `(when window-system
     (progn ,@body)))
#+END_SRC
*** Mode helpers
An easy way to enable many minor modes for many major modes all at once
#+BEGIN_SRC emacs-lisp
(defun enable-minor-modes (modes &keyword for)
  "Add a hook to enable minor modes on a mode switch"
  (cl-flet ((mklist (inp) (if (atom inp) (list inp) inp)))
    (let ((hooks (mapcar (lambda (mode)
                           (intern (concat (symbol-name mode) "-hook")))
                         (mklist for))))
      (mapcar (lambda (hook)
                (mapcar (lambda (mode) (add-hook hook mode)) (mklist modes)))
              hooks))))
#+END_SRC
** Setting up the package manager
I use [[https://github.com/raxod502/straight.el][straight.el]] for package management, because it produces a deterministic
output and can take packages from git.

Also, ~package.el~ often modifies ~custom.el~ and uses that as the basis for
which packages to load, as opposed to looking at my use of ~use-package~.

Finally, updating with ~package.el~ is a hassle. I'm hoping it's easier with
~straight.el~.

First, we need to bootstrap it.
#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC

I do want to continue to use ~use-package~, but we now need to load it in
another way
#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC

I'll tell ~use-package~ to always install a package using ~straight.el~ unless
told otherwise.
#+BEGIN_SRC emacs-lisp
(setq straight-use-package-by-default t)
#+END_SRC

I'm also always deferring loading, unless told otherwise using the ~:demand~ keyword.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t)
#+END_SRC

I do want to keep ~package.el~ for browsing packages on MELPA.
#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)
#+END_SRC

For configuring the packges, we have a few helpers. These make it obvious what
each invocation of ~use-package~ does.
#+BEGIN_SRC emacs-lisp
(defmacro ensure-package (package-name &rest args)
"Macro to ensure that a package is loaded. Every package that is used,
must at some point be installed using this macro."
  (declare (indent defun))
  `(use-package ,package-name
     :straight t
     ,@args))

(defmacro use-feature (package-name &rest args)
  "Macro to configure certain packages"
  (declare (indent defun))
  `(use-package ,package-name
     :straight nil
     ,@args))

(defmacro ensure-packages (&rest package-names)
  "Ensure that multiple packages are loaded"
  (declare (indent defun))
  `(progn
     ,@(mapcar (lambda (pkg) `(ensure-package ,pkg :demand t)) package-names)))
#+END_SRC

** Evil
It is said that Emacs is an awesome operating system, lacking only a decent text
editor. [[https://github.com/emacs-evil/evil][Evil-mode]] changes that, bringing modal editing to Emacs.
#+BEGIN_SRC emacs-lisp
  (ensure-package evil
    :demand t
    :init
            (setq evil-want-C-u-scroll t)
            (bvn/on-terminal
             (setq evil-want-C-i-jump nil)) ; Allow tabs in terminal
            (setq evil-want-C-w-in-emacs-state t) ; Allow window navigation in emacs state
    :config (evil-mode t))
#+END_SRC

For our keybinding needs, we'll use general.el

#+BEGIN_SRC emacs-lisp

#+END_SRC
*** Keybinding helpers
We like Vim style keybindings. These functions help.
#+BEGIN_SRC emacs-lisp
(defun kbd-or-fn (input)
  "Return the keyboard encoded sequence if input is a string. Otherwise, return the input, assuming it's a function."
  (if (stringp input)
      (kbd input)
    input))

(defun gmap (keys action)
  "Map keys to an action using `global-set-key`."
  (global-set-key (kbd keys) (kbd-or-fn action)))

(defun fmap (keybind-fn keys action)
  "Map keys to an action using `keybind-fn`."
  (call keybind-fn (kbd keys) (kbd-or-fn action)))

(defun xmap (keymap keys action &rest bindings)
  "Map keys to an action in the given `keymap`."
  (while keys
    (define-key keymap (kbd keys) (kbd-or-fn action))
    (setq keys (pop bindings)
          action (pop bindings))))

(defun xmap-keymap (state keymap keys action &rest bindings)
  "Map keys to an action in the given `keymap`."
  (while keys
    (evil-define-key state keymap (kbd keys) (kbd-or-fn action))
    (setq keys (pop bindings)
          action (pop bindings))))

(defun nmap (keymap keys action &rest bindings)
  "Map keys to an action in evil normal state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'normal keymap keys action bindings)
    (apply 'xmap evil-normal-state-map keys action bindings)))

(defun imap (keymap keys action &rest bindings)
  "Map keys to an action in evil insert state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'insert keymap keys action bindings)
    (apply 'xmap evil-insert-state-map keys action bindings)))

(defun vmap (keymap keys action &rest bindings)
  "Map keys to an action in evil visual state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'visual keymap keys action bindings)
    (apply 'xmap evil-visual-state-map keys action bindings)))

(defun mmap (keymap keys action &rest bindings)
  "Map keys to an action in evil motion state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'motion keymap keys action bindings)
    (apply 'xmap evil-motion-state-map keys action bindings)))

(defun emap (keymap keys action &rest bindings)
  "Map keys to an action in evil emacs state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'emacs keymap keys action bindings)
    (apply 'xmap evil-emacs-state-map keys action bindings)))
#+END_SRC

For many things in the minibuffer we like to change the behaviour of C-w and
C-r. This macro helps.
#+BEGIN_SRC emacs-lisp
(defmacro bvn/vimify-minibuffer (mode)
  `(xmap ,mode
         "C-w" 'evil-delete-backward-word
         "C-r" 'evil-paste-from-register))
#+END_SRC

*** Cleaning some keys
Use TAB to be, well, TAB.
#+BEGIN_SRC emacs-lisp
(gmap "TAB" 'self-insert-command)
#+END_SRC

Don't bind anything to backslash, space or comma. Yes, comma is something in
Vim, but I never use it, and do use it for my leader key.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil "\\" nil
                     "," nil
                     "SPC" nil)))
#+END_SRC
*** Command aliases
Ex commands are better when they're short
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "sus" 'suspend-emacs)
#+END_SRC
*** Cursor movement
In Vim I've made some changes to the way j and k work. I want them to move over
visual lines, not actual ones.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil  "j" evil-next-visual-line
                      "k" evil-previous-visual-line)))
#+END_SRC
Another change I've made in Vim is that C-u and C-d simply move the cursor, and
not the screen. This makes them usefull to jump a sizable distance, making it
easy to navigate a file. It's not truly the Vim way, but works just fine for me.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil "C-u" "20k"
                     "C-d" "20j")))
#+END_SRC
Because C-u is actually quite important in Emacs, we need to remap it.
#+BEGIN_SRC emacs-lisp
(gmap "M-C-U" 'universal-argument)
#+END_SRC

*** Commentary
Having an easy way to comment out lines is pretty awesome.
#+BEGIN_SRC emacs-lisp
(ensure-package evil-commentary
  :demand t
  :config (setq evil-commentary-mode t))
  
#+END_SRC
*** Surround
Vim-surround is one of Tim Pope's more useful plugins. And that says something.
#+BEGIN_SRC emacs-lisp
(ensure-package evil-surround
  :demand t
  :config (global-evil-surround-mode 1))
#+END_SRC
** Vimify
Some things, we really want just like in vim...

For starters, C-w and C-r.
#+BEGIN_SRC emacs-lisp
(gmap "C-w" 'evil-delete-backward-word)
(gmap "C-r" 'evil-paste-from-register)
; (xmap 'overriding-terminal-local-map "C-w" nil)
; (xmap 'overriding-terminal-local-map "C-r" nil)
#+END_SRC

This covers most cases, except for... isearch. Isearch is weird. It does not use
the minibuffer for text entry. It doesn't use a buffer, at all. 'Normal' text
editing is not a thing in Isearch. Because of that, we need to do some magic.

~isearch-kill-last-word~ deletes the last word in the search. On its own,
however, this isn't enough. Pressing ~DEL~ or ~BACKSPACE~ would /undo/ this
instead of deleting the next /last/ character, because ~isearch-delete-char~
undoes the last operation (which was to delete the last word).
#+BEGIN_SRC emacs-lisp
(defun isearch-kill-last-word ()
  (interactive)
  (setq isearch-suspended t)
   (with-temp-buffer
     (insert isearch-string)
     (backward-kill-word 1)
     (isearch-resume (buffer-string)
                     isearch-regexp
                     isearch-word
                     isearch-forward
                     (buffer-string)
                     isearch-case-fold-search)))

(defun isearch-kill-last-char ()
  (interactive)
  (setq isearch-suspended t)
   (with-temp-buffer
     (insert isearch-string)
     (backward-delete-char 1)
     (isearch-resume (buffer-string)
                     isearch-regexp
                     isearch-word
                     isearch-forward
                     (buffer-string)
                     isearch-case-fold-search)))

(xmap isearch-mode-map "C-w" 'isearch-kill-last-word)
(xmap isearch-mode-map "<DEL>" 'isearch-kill-last-char)
(xmap isearch-mode-map "<backspace>" 'isearch-kill-last-char)
#+END_SRC

C-g is the emergency escape in Emacs. I'd like it to also go into normal state
from insert state, since that cannot be moved to C-c.
#+BEGIN_SRC emacs-lisp
(imap nil "C-g" (lambda ()
                  (interactive)
                  (evil-normal-state)
                  (keyboard-quit)))
#+END_SRC
** Basic configuration
*** Keep modeline clean
The modeline gets pretty cluttered with all the minor modes enhancing Emacs
experience. In order to clean it up, I use blackout.

This allows me to add ~:blackout t~ to ~use-package~ definitions.
#+BEGIN_SRC emacs-lisp
(ensure-package blackout
  :straight (:host github :repo "raxod502/blackout")
  :demand t)
#+END_SRC
*** Color scheme
Gruvbox is the best color scheme, hands down.
#+BEGIN_SRC emacs-lisp
(ensure-package gruvbox-theme
  :demand t
  :config
  (load-theme 'gruvbox t))
#+END_SRC
*** Various quality of life settings
Show matching parentheses.
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode 1)
#+END_SRC

Use line numbers.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode t)
#+END_SRC

Show column numbers in the mode line
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

No cursor blinking
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

Indentation. Electric indent mode makes sure that when starting a new line,
enough whitespace is inserted. Inhibit ensures that only the /new/ line is
indented, while the previous line is left alone. This prevents Emacs from
messing up custom indentation, which is sometimes needed.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq-default electric-indent-mode t)
(setq-default electric-indent-inhibit t)
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
(setq tab-stop-list (number-sequence tab-width 200 tab-width))
#+END_SRC

Use UTF-8 as the default file encoding.
#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

Automatically reload files changed files.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

End all files with a newline
#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline t)
#+END_SRC

Highlight the current line.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
 
Store backups in a more central place.
#+BEGIN_SRC emacs-lisp
(defun bvn/generate-backup-file-name (file-path)
  "Generate and return a better file path for backups"
  (let* ((backup-root-dir "~/.emacs.d/tmp/")
         (sanitized-file-path (replace-regexp-in-string
                               "\\\\" "/" (replace-regexp-in-string
                                         "^\\([A-Za-z]\\):" "\\1/" file-path)))
         (full-file-path (replace-regexp-in-string
                          "//" "/" (concat backup-root-dir sanitized-file-path "~"))))
    (make-directory
     (file-name-directory full-file-path)
     (file-name-directory full-file-path))
    full-file-path))

(setq make-backup-file-name-function 'bvn/generate-backup-file-name
      backup-by-copying t)
#+END_SRC

Store auto saves in a more central place
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
  '((".*" "~/.emacs.d/tmp/" t)))
#+END_SRC
Do not create lock files.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

Keep some space when scrolling. Also, scrolling 1 row or column at a time is nicer.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 8)
(setq scroll-step 1)
(setq hscroll-margin 16)
(setq hscroll-step 1)
#+END_SRC

When splitting windows, keep some minimum space that makes sense. Preferably, I
want to be able to see at least 120 columns and at least 80 lines. This should
fit most code and paragraphs in a split.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold 160
      split-width-threshold 240)
#+END_SRC

Disable GUI fluff.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Set a slightly larger font. `set-face-attribute` already does nothing in
terminal Emacs, but it doesn't hurt to be specific.
#+BEGIN_SRC emacs-lisp
(bvn/on-gui
 (set-face-attribute 'default nil :height 140))
#+END_SRC
*** Automatically detect indent settings
dtrt-indent is like vim-sleuth, but for Emacs. It detects the indent settings of the current file.
Apparently, it's not on melpa-stable.
#+BEGIN_SRC emacs-lisp
(ensure-package dtrt-indent
  :demand t)
#+END_SRC
*** Helm
#+BEGIN_SRC emacs-lisp
  (ensure-package helm
    :defer t
    :config
    (helm-mode t)
    (setq helm-autoresize-mode t
          helm-follow-mode-persistent t)
    (gmap  "M-x" 'helm-M-x)
    (bvn/vimify-minibuffer helm-map)
    (dolist (mapfn '(nmap mmap))
      (apply mapfn '(nil ",fm" helm-mini
                         ",fe" helm-find-files))))
#+END_SRC

*** Free keys
#+BEGIN_SRC emacs-lisp
(ensure-package free-keys
  :defer t)
#+END_SRC
** Key bindings
which-key helps with discovery.
#+BEGIN_SRC emacs-lisp
(ensure-package which-key
  :demand t
  :config
    (setq which-key-idle-delay 0.5)
    (which-key-mode +1)
  :blackout t)
#+END_SRC
** Window layout
#+BEGIN_SRC emacs-lisp
(ensure-package popwin
  :config
  (dolist (mapfn '(nmap mmap))
    (apply mapfn '(nil ",wq" popwin:close-popup-window))))
#+END_SRC
** File navigation
Projectile is the package we use to deal with projects. We use helm-projectile to
integrate with helm.

Some things are best left alone. Therefore we ignore a bunch of files when
searching with Projectile.
#+BEGIN_SRC emacs-lisp
(ensure-package projectile
  :demand t
  :config
  (use-feature evil
    :config
    (evil-ex-define-cmd "ps" 'projectile-run-eshell)
    (nmap nil ",ps" 'projectile-run-eshell))

  (ensure-package helm-projectile
    :demand t
    :config
    (use-feature evil
      :config
      (dolist (mapfn '(nmap mmap))
        (apply mapfn '(nil ",ff" helm-projectile-find-file
                           ",fp" helm-projectile-switch-project))))

    (bvn/add-to-list 'projectile-globally-ignored-directories
                     ".git" ".hg" ".svn"
                     ".yardoc"
                     "public/images" "public/system" "data" "log" "tmp" "debug" "release"
                     "node_modules" "vendor" "quicklisp"
                     "_build"
                     ".merlin")

    (bvn/add-to-list 'projectile-globally-ignored-file-suffixes
                     ".exe" ".so" ".a" ".d" ".dll" ".o" ".fasl"
                     ".log" ".tlog"
                     ".dat"
                     ".sdf" 
                     ".pdf"
                     ".bcmap"
                     ".png" ".jpg" ".jpeg" ".svg"))
  (projectile-mode t))
#+END_SRC

One thing I did in vim was map switching between two buffers to \\
#+BEGIN_SRC emacs-lisp
(nmap nil "\\\\" 'evil-switch-to-windows-last-buffer)
(mmap nil "\\\\" 'evil-switch-to-windows-last-buffer)
#+END_SRC

** Search
#+BEGIN_SRC emacs-lisp
(ensure-package helm-ag
  :demand t
  :config
  (nmap nil ",sa" 'helm-ag-project-root
        ",sf" 'helm-ag-this-file
        ",sd" 'helm-do-ag-project-root))
#+END_SRC
** Source control
#+BEGIN_SRC emacs-lisp
(ensure-package magit
  :demand t
  :config
  (nmap nil ",gs" 'magit-status
            ",gb" 'magit-blame
            ",gB" 'magit-blame-quit
            ",gS" 'magit-stage-file
            ",gU" 'magit-unstage-file
            ",gl" 'magit-log
            ",gr" 'magit-rebase
            ",gd" 'magit-diff))
#+END_SRC

** Language support
*** TODO General
**** Auto completion
The common auto-complete front-end to Emacs is company-mode. Because company uses C-w
for 'show-location', and I want to use it to kill the previous word, the binding is removed.
It's bound to C-l instead.
#+BEGIN_SRC emacs-lisp
(ensure-package company
  :demand
  :config
  (xmap company-active-map
        "C-w" nil
        "C-l" 'company-show-location
        "C-n" 'company-select-next
        "C-p" 'company-select-previous
        "TAB" 'company-complete-common-or-cycle
        "ESC" 'company-abort))

(defun company/set-backend (backend)
  (set (make-local-variable 'company-backends) (list backend 'company-semantic 'company-files)))
#+END_SRC

We're going to be using different completion engines for different
languages. Each of these will be set up individually in their
languages heading.
**** Syntax checking
#+BEGIN_SRC emacs-lisp
(ensure-package flycheck
  :demand t
  :config
  (nmap nil ",cl" 'flycheck-list-errors
        ",cn" 'flycheck-next-error
        ",cp" 'flycheck-previous-error)
  (use-feature popwin
    :config
    (push '("*Flycheck errors*" :position bottom :stick t :noselect t :height 0.4)
          popwin:special-display-config)))
#+END_SRC
**** LSP
Language Server Protocol support makes it easy to add IDE-like integration for
many languages.
#+BEGIN_SRC emacs-lisp
(ensure-package eglot
  :demand)
#+END_SRC
*** TODO C#
*** TODO C++
*** TODO Common Lisp
**** Language support
#+BEGIN_SRC emacs-lisp
(ensure-package slime
  :demand t
  :init
  (setq slime-complete-symbol*-fancy t)
  :config 
  (use-feature evil
    :config
    (dolist (map-fn '(nmap vmap mmap))
      (apply map-fn lisp-mode-map
             '(",'"  qlot-slime-start

               ",cc" slime-compile-file
               ",cC" slime-compile-and-load-file
               ",cl" slime-load-file
               ",cf" slime-compile-defun
               ",cr" slime-compile-region
               ",cn" slime-remove-notes

               ",eb" slime-eval-buffer
               ",ef" slime-eval-defun
               ",eF" slime-undefine-function
               ",ee" slime-eval-last-expression
               ",er" slime-eval-region

               ",gb" slime-pop-find-definition-stack
               ",gn" slime-next-note
               ",gN" slime-previous-note

               ",ha" slime-apropos
               ",hA" slime-apropos-all
               ",hd" slime-disassemble-symbol
               ",hh" slime-describe-symbol
               ",hH" slime-hyperspec-lookup
               ",hi" slime-inspect-definition
               ",hp" slime-apropos-package
               ",ht" slime-toggle-trace-fdefinition
               ",hT" slime-untrace-all
               ",h<" slime-who-calls
               ",h>" slime-calls-who

               ",hr" slime-who-references
               ",hm" slime-who-macroexpands
               ",hs" slime-who-specializes

               ",ma" slime-macroexpand-all
               ",mo" slime-macroexpand-1

               ",se" slime-eval-last-expression-in-repl
               ",si" qlot-slime-start
               ",sq" slime-quit-lisp

               ",tf" slime-toggle-fancy-trace)))))
(ensure-package paredit :demand t)

  (defun qlot-slime-start ()
    (interactive)
    (let ((directory (projectile-project-root)))
      (slime-start :program "qlot"
                   :program-args '("exec" "ros" "-S" "." "run" "--" "--dynamic-space-size" "4096")
                   :directory directory
                   :name 'qlot
                   :env (list (concat "PATH="
                                      (mapconcat 'identity exec-path ":"))
                              (concat "QUICKLISP_HOME="
                                      (file-name-as-directory directory) "quicklisp/")))))
#+END_SRC	
**** Auto complete
#+BEGIN_SRC emacs-lisp
(use-feature slime
  :config
  (ensure-package slime-company)
  :config
  (defun common-lisp/add-to-company ()
    (set (make-local-variable 'company-backends) '(company-slime)))
  (add-hook 'lisp-mode-hook
            (lambda ()
              (interactive)
              (common-lisp/add-to-company)
              (company-mode t))))
#+END_SRC
*** TODO CSS
*** TODO Elixir
#+BEGIN_SRC emacs-lisp
(ensure-package elixir-mode
:demand t
:config
  (ensure-package company)
  (ensure-package alchemist
    :after company)
  (add-hook 'elixir-mode-hook
    (lambda ()
      (interactive)
      (alchemist-mode)
      (company/set-backend 'alchemist-company)
      (company-mode t)))
  (ensure-package flycheck
  :config
    (ensure-package flycheck-credo)))
#+END_SRC
	
*** TODO F#
#+BEGIN_SRC emacs-lisp
(ensure-package fsharp-mode
:demand t
:config
  (ensure-package eglot-fsharp
    :demand t)
  (add-hook 'fsharp-mode-hook (lambda ()
    (interactive)
    (enable-minor-modes '(company-mode dtrt-indent-mode) :for 'fsharp-mode)
    (eglot-ensure))))
#+END_SRC
*** TODO HTML
*** TODO Java
*** TODO Javascript
#+BEGIN_SRC emacs-lisp
(enable-minor-modes 'dtrt-indent-mode :for 'js-mode)
#+END_SRC
*** TODO Markdown
#+BEGIN_SRC emacs-lisp
(ensure-package markdown-mode
  :demand t
  :mode 
  (("\\.md" . markdown-mode)
   ("\\.markdown" . markdown-mode))
  :config
  (defun markdown-mode-hook/configure ()
    (setq fill-column 80)
    (auto-fill-mode t))

  (add-hook 'markdown-mode-hook 'markdown-mode-hook/configure))
#+END_SRC
*** TODO OCaml
#+BEGIN_SRC emacs-lisp
(ensure-packages
  merlin
  ocp-indent
  utop
  tuareg)

(defun ocaml/initialize-opam ()
  (if (executable-find "opam")
      (let* ((output (shell-command-to-string
                      "opam config var share 2> /dev/null"))
             (share (when (< 0 (length output))
                      (substring output 0 -1))))
        (when share
          (setq opam-share share
                opam-load-path (concat share "/emacs/site-lisp")))
        (add-to-list 'load-path opam-load-path))
    (message (concat "Cannot find \"opam\" executable. "
                     "OCaml language support won't work properly."))))

(defun ocaml/merlin-locate ()
  (interactive)
  (let ((merlin-locate-in-new-window 'never))
    (merlin-locate)))

(defun ocaml/merlin-locate-other-window ()
  (interactive)
  (let ((merlin-locate-in-new-window 'always))
    (merlin-locate)))

(use-feature tuareg ; this is the ocaml mode
  :mode
  (("\\.ml[ily]?$" . tuareg-mode)
   ("\\.topml$" . tuareg-mode))

  :config
  ;; Merlin is for auto completion
  (use-feature merlin
    :hook (tuareg-mode . merlin-mode)
    :config
    (add-hook 'merlin-mode-hook
              (lambda ()
                (interactive)
                (setq merlin-completion-with-doc t)
                (set (make-local-variable 'company-backends) '(merlin-company-backend))))

    (use-feature evil
      :config
    (nmap tuareg-mode-map
          ",cp" 'merlin-project-check
          ",cv" 'merlin-goto-project-file
          ",eC" 'merlin-error-check
          ",en" 'merlin-error-next
          ",eN" 'merlin-error-prev
          ",gb" 'merlin-pop-stack
          ",gG" 'ocaml/merlin-locate-other-window
          ",gl" 'merlin-locate-ident
          ",gi" 'merlin-switch-to-ml
          ",gI" 'merlin-switch-to-mli
          ",go" 'merlin-occurrences
          ",hh" 'merlin-document
          ",ht" 'merlin-type-enclosing
          ",hT" 'merlin-type-expr
          ",rd" 'merlin-destruct)))

  ;; We must do keybindings _after_ loading evil
  (ocaml/initialize-opam)
  (use-feature evil
    :config
    (nmap tuareg-mode-map
          ",ga" 'tuareg-find-alternate-file
          ",cc" 'projectile-compile-project))

  (use-feature utop
    :hook (tuareg-mode . utop-minor-mode)
    :config
    (setq utop-command "opam config exec -- utop -emacs")
    (use-feature evil
      :config
      (nmap tuareg-mode-map
            ",'"  'utop
            ",sb" 'utop-eval-buffer
            ",si" 'utop
            ",sp" 'utop-eval-phrase
            ",sr" 'utop-eval-region))))

;(defun ocaml/ocp-indent-config ()
  ;(add-hook 'tuareg-mode-hook 'ocp-indent-caml-mode-setup)
  ;(dolist (map-fn '(nmap vmap))
    ;(apply map-fn '(nil "=" ocp-indent-buffer))))
#+END_SRC
*** TODO Python
**** Language support
On Windows, we're likely to use the Python version chooser 'py'.
#+BEGIN_SRC emacs-lisp
(bvn/on-windows
  (setq python-shell-interpreter "py"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ensure-package anaconda-mode
  :hook python-mode)
#+END_SRC
**** Auto completion
#+BEGIN_SRC emacs-lisp
(ensure-package company-anaconda
  :config
  (add-hook 'python-mode-hook
    (lambda () (add-to-list 'company-backends 'company-anaconda))))

  (defun python/add-to-company ()
    (add-to-list 'company-backends 'company-anaconda))
  (add-hook 'python-mode-hook 'python/add-to-company)
#+END_SRC
**** Syntax checking
*** TODO Ruby
#+BEGIN_SRC emacs-lisp
(ensure-packages enh-ruby-mode
              robe
              rspec-mode)

(ensure-package enh-ruby-mode
  :demand t
  :mode
  (("Appraisals\\'" . enh-ruby-mode)
   ("\\(Rake\\|Thor\\|Guard\\|Gem\\|Cap\\|Vagrant\\|Berks\\|Pod\\|Puppet\\)file\\'" . enh-ruby-mode)
   ("\\.\\(rb\\|rabl\\|ru\\|builder\\|rake\\|thor\\|gemspec\\|jbuilder\\)\\'" . enh-ruby-mode))

  :config
  (setq enh-ruby-add-encoding-comment-on-save nil)

  (use-feature evil
    :config
    (require 'ruby-mode)
    (evil-define-motion evil-ruby-jump-item (count)
      :jump t
      :type inclusive
      (cond ((string-match ruby-block-beg-re (current-word))
             (enh-ruby-end-of-block count))
            ((string-match ruby-block-end-re (current-word))
             (enh-ruby-beginning-of-block count))
            (t (evil-jump-item count))))

    (add-hook 'enh-ruby-mode-hook
              (lambda ()
                (interactive)
                (nmap enh-ruby-mode-map "%" 'evil-ruby-jump-item)
                (mmap enh-ruby-mode-map "%" 'evil-ruby-jump-item))))

  (use-feature dtrt-indent
    :hook (enh-ruby-mode . dtrt-indent-mode))

  (use-feature robe
    :hook (enh-ruby-mode . robe-mode))

  (use-feature company
    :config
    (add-hook 'enh-ruby-mode-hook
              (lambda ()
                (interactive)
                (set (make-local-variable 'company-backends) '(company-robe))))
  :hook (enh-ruby-mode . company-mode))

  (use-feature flycheck
    :hook (enh-ruby-mode . flycheck-mode))

  (use-feature rspec-mode
    :config
    (setq rspec-use-spring-when-possible t)
    (setq rspec-autosave-buffer t)
    (use-feature evil
      :config
      (dolist (mapfn '(nmap mmap))
        (apply mapfn '(nil ",ta" rspec-verify-all
                           ",tb" rspec-verify
                           ",tc" rspec-verify-continue
                           ",tp" rspec-toggle-example-pendingness
                           ",tf" rspec-run-last-failed
                           ",tr" rspec-rerun
                           ",tt" rspec-verify-single
                           ",t~" rspec-find-spec-or-target-find-example-other-window
                           ",t TAB" rspec-find-spec-or-target-other-window
                           ",ti" comint-mode)))))
  (use-feature inf-ruby
    :config
    (use-feature evil
      :config
      (use-feature rspec-mode
        :config
        (mmap rspec-compilation-mode-map ",td" 'inf-ruby-switch-from-compilation))))

  (use-feature popwin
    :config
    (push '("*rspec-compilation*" :position bottom :stick t :noselect t :height 0.4)
          popwin:special-display-config)))
#+END_SRC

Robe has a nice function to start it, but not one to stop it. Naively killing
the buffer can lead to issues on Mac OS, so here's a function to nicely kill
Robe's ruby process and buffer.
#+BEGIN_SRC emacs-lisp
(defun robe-stop ()
  (interactive)
  (let* ((buffer (robe-inf-buffer))
         (process (get-buffer-process buffer)))
    (when process (delete-process process))
    (when buffer (kill-buffer buffer))))
#+END_SRC
*** TODO YAML
** Software support
*** TODO Org mode
The built-in org-mode is old. So we use a newer.
#+BEGIN_SRC emacs-lisp
(ensure-package org
  :config
  (setq org-startup-indented t)
  (setq org-src-fontify-natively t)
  (add-hook 'org-mode-hook (lambda () 
                             (setq fill-column 80)
                             (auto-fill-mode t)))
  (defun org-mode-indent-source ()
    (interactive)
    (org-edit-special)
    (evil-indent (point-min) (point-max))
    (org-edit-src-exit))


  (nmap nil ",=" 'org-mode-fmt-source)
  (xmap org-mode-map "C-c l" 'org-store-link
                     "C-c a" 'org-agenda)

  (org-reload))
#+END_SRC
**** Keybindings
Evil has some keybindings that conflict with org mode. Fix them.
#+BEGIN_SRC emacs-lisp
(defun bvn/org-mode-bindings ()
  (nmap nil "TAB" 'org-cycle))
(add-hook 'org-mode-hook 'bvn/org-mode-bindings)
#+END_SRC
*** TODO org-roam
Using org-roam for note taking.
#+BEGIN_SRC emacs-lisp
(ensure-package org-roam
  :demand t
  :hook (after-init . org-roam-mode)
  :custom
  (org-roam-directory "~/.org-roam")
  (org-roam-db-location "~/.org-roam/org-roam.db")
  (org-roam-capture-templates
    '(("d" "default" plain #'org-roam-capture--get-point "%?"
       :file-name "%<%Y%m%d%H%M%S-%N>"
       :head "#+title: ${title}"
       :unnarrowed t))) ;; Remove the slug from the default file name, to prevent file name changing
  :config
  :bind (:map org-roam-mode-map
              (("C-c n n" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n g" . org-roam-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))
              (("C-c n I" . org-roam-insert-immediate))))
#+END_SRC
*** TODO Docker
#+BEGIN_SRC emacs-lisp
(ensure-package dockerfile-mode)

(defun docker/dockerfile-mode-mode ()
  '(("Dockerfile\\'" . dockerfile-mode)))
#+END_SRC
*** TODO Terraform
#+BEGIN_SRC emacs-lisp
(ensure-packages hcl-mode terraform-mode company-terraform)
(use-feature terraform-mode
  :config
  (use-feature company-terraform
    :after company
    :config
    (add-hook 'terraform-mode-hook
              (lambda ()
                (interactive)
                (company-mode t)
                (company/set-backend 'company-terraform)))))
#+END_SRC
** Getting Things Done
I'll be using ~org-mode~ for implementing Getting Things Done. However, I don't
want GTD to intervene with regular ~org-mode~. Therefore, we'll have a few
helpers.

One of the things I want to do is to show what next key to press in order to do
the next thing. For this, I might set up a Hydra, or use which-keys, or...

*** Inbox processing
Currently, the inbox is just a single file. ~$HOME/,gtd/inbox.org~. From this
file, we want to file to a number of other files. For starters, we'll just split
out ~projects.org~.

The binding, right now, is not really Hydra, but that's fine.
#+BEGIN_SRC emacs-lisp
(defun gtd/org-refile ()
  (interactive)
  (setq lexical-binding t)
  (let ((org-refile-targets
         '(
           (nil :maxlevel . 1)
           ("~/.gtd/next.org" :maxlevel . 1)
           ("~/.gtd/projects.org" :maxlevel . 2) ;; active / inactive
           ("~/.gtd/rejected.org" :maxlevel . 1)
           ("~/.gtd/finished.org" :maxlevel . 1)
           ;; ("~/.gtd/backlog.org" :maxlevel . 1)
           )))
    (org-refile))) 

  (nmap org-mode-map ",mr" 'gtd/org-refile)
#+END_SRC
** Everything so far, which isn't a lot
#+BEGIN_SRC emacs-lisp
(nmap nil ",ll" 'eval-last-sexp)
#+END_SRC
*** Move custom to its own file
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'noerror)
#+END_SRC
