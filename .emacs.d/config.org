#+TITLE: Emacs configuration file
#+AUTHOR: Bart van Nierop

* Config
** TODOS
*** TODO Bindings
https://github.com/magit/magit/issues/1968
*** TODO Run through Vim config
**** TODO plugins
***** DONE Commentary
***** DONE Dispatch (not needed)
***** DONE Surround
***** DONE Sleuth (could be solved with local configs)
See: dtrt-indent
***** DONE CtrlP (Helm / Projectile)
***** TODO YouCompleteMe (autocompletion / company + providers)
***** TODO Search (ack/ag)
***** TODO Fugitive (Magit)
***** TODO Slimv (Slime)
***** TODO Jsx
***** TODO Ragtag (html editing)
***** TODO Ale (flycheck?)
***** TODO Tmux
*** TODO Open special windows in a normal place
*** TODO Autocomplete
*** TODO Indent size, spaces, etc.
*** TODO Layout management / tmux / screen
*** TODO Language support
*** TODO Magit
*** TODO Hydra
https://github.com/abo-abo/hydra
*** TODO Line width
*** TODO Helm open buffer with <RET>?
*** TODO Company don't complete with <RET>
** Utility functions
*** Lexical binding
Since Emacs 24, Emacs Lisp supports lexical binding. Since this makes lisp much
more powerful, we enable it.
#+BEGIN_SRC emacs-lisp
(setq lexical-binding t)
#+END_SRC
*** List helpers
#+BEGIN_SRC emacs-lisp
(defun bvn/add-to-list (target-list val &rest values)
  (while val
    (add-to-list target-list val)
    (setq val (pop values))))
#+END_SRC
*** Function helpers
The function below helps us find functions that have a certain suffix
as name. The goal is to support dynamic configuration of plugins.
#+BEGIN_SRC emacs-lisp
(defun find-functions-with-suffix (suffix)
  (let ((functions nil))
    (mapatoms (lambda (a)
                (when (and (fboundp a)
                           (string-suffix-p suffix (symbol-name a)))
                  (push a functions))))
    functions))
#+END_SRC
It is used like this:
(defun foobarbaz-config ()
  (mapc 'funcall
        (functions-with-suffix "/foobarbaz-config")))

(defun ruby/foobarbaz-config ()
  (interactive)
  (message "called!"))
*** OS helpers
The following macros only execute their body on the given operating system.
#+BEGIN_SRC emacs-lisp
(defmacro bvn/on-windows (&rest body)
  `(if (eq system-type 'windows-nt)
     (progn ,@body)))

(defmacro bvn/on-terminal (&rest body)
  `(unless window-system
     (progn ,@body)))

(defmacro bvn/on-gui (&rest body)
  `(when window-system
     (progn ,@body)))
#+END_SRC
** Setting up the package manager
Note: For this to work on windows, gnutls needs to be installed. Binaries can be
gotten from https://www.gnutls.org/download.html and can be unpacked into the emacs root
folder (so that .../bin and .../lib match).
#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)

(setq package-enable-at-startup nil)
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+END_SRC

For configuring the packages, we have a few helpers. This allows us to
create language specific functions for configuring packages.

Instead of `use_package`, we can use `bvn/use-packages` throughout the
config. Duplicates don't matter. At the end of the config, we put
`bvn/load-packages` which actually loads and uses the packages.

Package `init` and `config` functions can be defined semantically:
`prefix/package-init` and `prefix/package-config`.
#+BEGIN_SRC emacs-lisp
(defvar bvn/packages ())

(defmacro bvn/use-packages (package-name &rest package-names)
  `(eval-when-compile
     (let ((package-name ',package-name)
           (package-names ',package-names))
       (while package-name
         (push package-name bvn/packages)
         (setq package-name (pop package-names))))))

(defmacro bvn/load-packages ()
  (let ((packages (reverse bvn/packages)))
    (delete-dups packages)
    `(progn
       ,@(mapcar 'bvn/load-packages--use-block packages)
       (setq bvn/packages nil))))

(defun bvn/load-packages--use-block (package)
  (let ((mode (bvn/load-packages--collect-configuration-fns package "mode")))
    `(use-package ,package
       :ensure t
       :mode ,mode
       :init (bvn/load-packages--call-configuration-fns ',package "init")
       :config (bvn/load-packages--call-configuration-fns ',package "config"))))

(defun bvn/load-packages--call-configuration-fns (package-name action)
  (mapcar 'funcall
        (find-functions-with-suffix (concat "/" (symbol-name package-name) "-" action))))

(defun bvn/load-packages--collect-configuration-fns (package-name action)
  (apply 'append
         (mapcar 'funcall
                 (find-functions-with-suffix (concat "/" (symbol-name package-name) "-" action)))))
#+END_SRC

** Evil
It is said that Emacs is an awesome operating system, lacking only a decent text
editor. [[https://github.com/emacs-evil/evil][Evil-mode]] changes that, bringing modal editing to Emacs.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init (progn
          (setq evil-want-C-u-scroll t)
          (bvn/on-terminal
           (setq evil-want-C-i-jump nil)) ; Allow tabs in terminal
          (setq evil-want-C-w-in-emacs-state t)) ; Allow window navigation in emacs state
  :config (evil-mode t))
#+END_SRC
*** Keybinding helpers
We like Vim style keybindings. These functions help.
#+BEGIN_SRC emacs-lisp
(defun kbd-or-fn (input)
  "Return the keyboard encoded sequence if input is a string. Otherwise, return the input, assuming it's a function."
  (if (stringp input)
      (kbd input)
    input))

(defun gmap (keys action)
  "Map keys to an action using `global-set-key`."
  (global-set-key (kbd keys) (kbd-or-fn action)))

(defun fmap (keybind-fn keys action)
  "Map keys to an action using `keybind-fn`."
  (call keybind-fn (kbd keys) (kbd-or-fn action)))

(defun xmap (keymap keys action &rest bindings)
  "Map keys to an action in the given `keymap`."
  (while keys
    (define-key keymap (kbd keys) (kbd-or-fn action))
    (setq keys (pop bindings)
          action (pop bindings))))

(defun xmap-keymap (state keymap keys action &rest bindings)
  "Map keys to an action in the given `keymap`."
  (while keys
    (evil-define-key state keymap (kbd keys) (kbd-or-fn action))
    (setq keys (pop bindings)
          action (pop bindings))))

(defun nmap (keymap keys action &rest bindings)
  "Map keys to an action in evil normal state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'normal keymap keys action bindings)
    (apply 'xmap evil-normal-state-map keys action bindings)))

(defun imap (keymap keys action &rest bindings)
  "Map keys to an action in evil insert state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'insert keymap keys action bindings)
    (apply 'xmap evil-insert-state-map keys action bindings)))

(defun vmap (keymap keys action &rest bindings)
  "Map keys to an action in evil visual state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'visual keymap keys action bindings)
    (apply 'xmap evil-visual-state-map keys action bindings)))

(defun mmap (keymap keys action &rest bindings)
  "Map keys to an action in evil motion state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'motion keymap keys action bindings)
    (apply 'xmap evil-motion-state-map keys action bindings)))

(defun emap (keymap keys action &rest bindings)
  "Map keys to an action in evil emacs state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'emacs keymap keys action bindings)
    (apply 'xmap evil-emacs-state-map keys action bindings)))
#+END_SRC

For many things in the minibuffer we like to change the behaviour of C-w and
C-r. This macro helps.
#+BEGIN_SRC emacs-lisp
(defmacro bvn/vimify-minibuffer (mode)
  `(xmap ,mode
         "C-w" 'evil-delete-backward-word
         "C-r" 'evil-paste-from-register))
#+END_SRC

*** Cleaning some keys
Use TAB to be, well, TAB.
#+BEGIN_SRC emacs-lisp
(gmap "TAB" 'self-insert-command)
#+END_SRC

Don't bind anything to backslash, space or comma. Yes, comma is something in
Vim, but I never use it, and do use it for my leader key.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil "\\" nil
                     "," nil
                     "SPC" nil)))
#+END_SRC
*** Command aliases
Ex commands are better when they're short
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "sus" 'suspend-emacs)
#+END_SRC
*** Cursor movement
In Vim I've made some changes to the way j and k work. I want them to move over
visual lines, not actual ones.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil  "j" evil-next-visual-line
                      "k" evil-previous-visual-line)))
#+END_SRC
Another change I've made in Vim is that C-u and C-d simply move the cursor, and
not the screen. This makes them usefull to jump a sizable distance, making it
easy to navigate a file. It's not truly the Vim way, but works just fine for me.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil "C-u" "20k"
                     "C-d" "20j")))
#+END_SRC
Because C-u is actually quite important in Emacs, we need to remap it.
#+BEGIN_SRC emacs-lisp
(gmap "M-C-U" 'universal-argument)
#+END_SRC

*** Commentary
Having an easy way to comment out lines is pretty awesome.
#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :ensure t
  :config (setq evil-commentary-mode t))
  
#+END_SRC
*** Surround
Vim-surround is one of Tim Pope's more useful plugins. And that says something.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :config (global-evil-surround-mode 1))
#+END_SRC
** Vimify
Some things, we really want just like in vim...

For starters, C-w and C-r.
#+BEGIN_SRC emacs-lisp
(gmap "C-w" 'evil-delete-backward-word)
(gmap "C-r" 'evil-paste-from-register)
; (xmap 'overriding-terminal-local-map "C-w" nil)
; (xmap 'overriding-terminal-local-map "C-r" nil)
#+END_SRC

C-g is the emergency escape in Emacs. I'd like it to also go into normal state
from insert state, since that cannot be moved to C-c.
#+BEGIN_SRC emacs-lisp
(imap nil "C-g" (lambda ()
                  (interactive)
                  (evil-normal-state)
                  (keyboard-quit)))
#+END_SRC
** Basic configuration
*** Color scheme
Gruvbox is the best color scheme, hands down.
#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :ensure t
  :config
  (load-theme 'gruvbox t))
#+END_SRC
*** Various quality of life settings
Show matching parentheses.
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode 1)
#+END_SRC

Use line numbers.
#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
(setq linum-mode "%d ")
#+END_SRC

Show column numbers in the mode line
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

No cursor blinking
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

Indentation.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
(setq tab-stop-list (number-sequence tab-width 200 tab-width))
#+END_SRC

Use UTF-8 as the default file encoding.
#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

Automatically reload files changed files.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

Highlight the current line.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
 
Store backups in a more central place.
#+BEGIN_SRC emacs-lisp
(defun bvn/generate-backup-file-name (file-path)
  "Generate and return a better file path for backups"
  (let* ((backup-root-dir "~/.emacs.d/tmp/")
         (sanitized-file-path (replace-regexp-in-string
                               "\\\\" "/" (replace-regexp-in-string
                                         "^\\([A-Za-z]\\):" "\\1/" file-path)))
         (full-file-path (replace-regexp-in-string
                          "//" "/" (concat backup-root-dir sanitized-file-path "~"))))
    (make-directory
     (file-name-directory full-file-path)
     (file-name-directory full-file-path))
    full-file-path))

(setq make-backup-file-name-function 'bvn/generate-backup-file-name
      backup-by-copying t)
#+END_SRC

Store auto saves in a more central place
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
  '((".*" "~/.emacs.d/tmp/" t)))
#+END_SRC
Do not create lock files.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

Keep some space when scrolling. Also, scrolling 1 row or column at a time is nicer.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 8)
(setq scroll-step 1)
(setq hscroll-margin 16)
(setq hscroll-step 1)
#+END_SRC

When splitting windows, keep some minimum space that makes sense. Preferably, I
want to be able to see at least 120 columns and at least 80 lines. This should
fit most code and paragraphs in a split.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold 160
      split-width-threshold 240)
#+END_SRC

Disable GUI fluff.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Set a slightly larger font. `set-face-attribute` already does nothing in
terminal Emacs, but it doesn't hurt to be specific.
#+BEGIN_SRC emacs-lisp
(bvn/on-gui
 (set-face-attribute 'default nil :height 140))
#+END_SRC
*** Automatically detect indent settings
dtrt-indent is like vim-sleuth, but for Emacs. It detects the indent settings of the current file.
Apparently, it's not on melpa-stable.
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
  :config
  (setq dtrt-indent-mode t))
#+END_SRC
*** Helm
#+BEGIN_SRC emacs-lisp
(bvn/use-packages helm)

(defun helm/helm-config ()
  (helm-mode t)
  (setq helm-autoresize-mode t
        helm-follow-mode-persistent t)
  (gmap  "M-x" 'helm-M-x)
  (bvn/vimify-minibuffer helm-map)
  (dolist (mapfn '(nmap mmap))
    (apply mapfn '(nil ",fm" helm-mini
                       ",fe" helm-find-files))))
#+END_SRC

*** Free keys
#+BEGIN_SRC emacs-lisp
(use-package free-keys
  :ensure t)
#+END_SRC
** Window layout
#+BEGIN_SRC emacs-lisp
(bvn/use-packages popwin)

(defun popwin/popwin-config ()
  (dolist (mapfn '(nmap mmap))
    (apply mapfn '(nil ",wq" popwin:close-popup-window))))
#+END_SRC
** File navigation
Projectile is the package we use to deal with projects. We use helm-projectile to
integrate with helm.

Some things are best left alone. Therefore we ignore a bunch of files when searching with Projectile.
#+BEGIN_SRC emacs-lisp
  (bvn/use-packages projectile helm-projectile)

  (defun projectile/projectile-config ()
    (projectile-mode t))

  (defun helm-projectile/helm-projectile-config ()
    (dolist (mapfn '(nmap mmap))
      (apply mapfn '(nil ",ff" helm-projectile-find-file
                         ",fp" helm-projectile-switch-project)))

    (bvn/add-to-list 'projectile-globally-ignored-directories
      ".git" ".hg" ".svn"
      ".yardoc"
      "public/images" "public/system" "data" "log" "tmp" "debug" "release"
      "node_modules" "vendor")

    (bvn/add-to-list 'projectile-globally-ignored-file-suffixes
      ".exe" ".so" ".a" ".d" ".dll" ".o" ".fasl"
      ".log" ".tlog"
      ".dat"
      ".sdf" 
      ".pdf"
      ".bcmap"
      ".png" ".jpg" ".jpeg" ".svg"))
#+END_SRC

One thing I did in vim was map switching between two buffers to \\
#+BEGIN_SRC emacs-lisp
(nmap nil "\\\\" 'evil-switch-to-windows-last-buffer)
(mmap nil "\\\\" 'evil-switch-to-windows-last-buffer)
#+END_SRC

** Search
#+BEGIN_SRC emacs-lisp
(bvn/use-packages helm-ag)

(defun helm-ag/helm-ag-config ()
  (nmap nil ",sa" 'helm-ag-project-root
        ",sf" 'helm-ag-this-file
        ",sd" 'helm-do-ag-project-root))
#+END_SRC
** Source control
#+BEGIN_SRC emacs-lisp
(bvn/use-packages magit)

(defun magit/magit-config ()
  (nmap nil ",gs" 'magit-status
            ",gb" 'magit-blame
            ",gB" 'magit-blame-quit
            ",gS" 'magit-stage-file
            ",gU" 'magit-unstage-file
            ",gl" 'magit-log
            ",gr" 'magit-rebase
            ",gd" 'magit-diff))
#+END_SRC

** Language support
*** TODO General
**** Auto completion
The common auto-complete front-end to Emacs is company-mode. Because company uses C-w
for 'show-location', and I want to use it to kill the previous word, the binding is removed.
It's bound to C-l instead.
#+BEGIN_SRC emacs-lisp
(bvn/use-packages company)
(defun company/company-config ()
  (xmap company-active-map
        "C-w" nil
        "C-l" 'company-show-location
        "C-n" 'company-select-next
        "C-p" 'company-select-previous
        "TAB" 'company-complete-common-or-cycle
        "ESC" 'company-abort))
#+END_SRC

We're going to be using different completion engines for different
languages. Each of these will be set up individually in their
languages heading.
**** Syntax checking
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)

(defun flycheck/flycheck-config ()
  (nmap nil ",cl" 'flycheck-list-errors
        ",cn" 'flycheck-next-error
        ",cp" 'flycheck-previous-error))

(defun flycheck/popwin-config ()
  (push '("*Flycheck errors*" :position bottom :stick t :noselect t :height 0.4)
        popwin:special-display-config))
#+END_SRC
*** TODO C#
*** TODO C++
*** TODO Common Lisp
*** TODO CSS
*** TODO HTML
*** TODO Java
*** TODO Javascript
*** TODO Markdown
#+BEGIN_SRC emacs-lisp
(bvn/use-packages markdown-mode)

(defun markdown/markdown-mode-mode ()
  '(("\\.md" . markdown-mode)
    ("\\.markdown" . markdown-mode)))

(defun markdown-mode-hook/configure ()
  (setq fill-column 80)
  (auto-fill-mode t))

(add-hook 'markdown-mode-hook 'markdown-mode-hook/configure)
#+END_SRC
*** TODO Python
**** Language support
On Windows, we're likely to use the Python version chooser 'py'.
#+BEGIN_SRC emacs-lisp
(bvn/on-windows
  (setq python-shell-interpreter "py"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(bvn/use-packages anaconda-mode)

(defun python/anaconda-mode-config ()
  (add-hook 'python-mode-hook 'anaconda-mode))
#+END_SRC
**** Auto completion
#+BEGIN_SRC emacs-lisp
(bvn/use-packages company-anaconda)

(defun python/add-to-company ()
  (add-to-list 'company-backends 'company-anaconda))
(add-hook 'python-mode-hook 'python/add-to-company)
#+END_SRC
**** Syntax checking
*** TODO Ruby
#+BEGIN_SRC emacs-lisp
  (bvn/use-packages popwin
                    company
                    enh-ruby-mode
                    flycheck
                    rspec-mode
                    inf-ruby
                    slim-mode
                    robe)

  (defun ruby/enh-ruby-mode-mode ()
    '(("Appraisals\\'" . enh-ruby-mode)
      ("\\(Rake\\|Thor\\|Guard\\|Gem\\|Cap\\|Vagrant\\|Berks\\|Pod\\|Puppet\\)file\\'" . enh-ruby-mode)
      ("\\.\\(rb\\|rabl\\|ru\\|builder\\|rake\\|thor\\|gemspec\\|jbuilder\\)\\'" . enh-ruby-mode)))

  (defun ruby/add-to-company ()
    (set (make-local-variable 'company-backends) '(company-robe)))

  (defun ruby/company-config ()
    (dolist (hook '(ruby-mode-hook enh-ruby-mode-hook))
      (add-hook hook 'ruby/add-to-company)))

  (defun ruby/flycheck-config ()
    (dolist (hook '(ruby-mode-hook enh-ruby-mode-hook))
      (add-hook hook 'flycheck-mode)))

  (defun ruby/robe-config ()
    (dolist (hook '(ruby-mode-hook enh-ruby-mode-hook))
      (add-hook hook 'robe-mode)))

  (defun ruby/rspec-mode-config ()
    (setq rspec-use-spring-when-possible nil)
    (setq rspec-autosave-buffer t)
    (dolist (mapfn '(nmap mmap))
      (apply mapfn '(nil ",ta" rspec-verify-all
                         ",tb" rspec-verify
                         ",tc" rspec-verify-continue
                         ",tp" rspec-toggle-example-pendingness
                         ",tf" rspec-run-last-failed
                         ",tr" rspec-rerun
                         ",tt" rspec-verify-single
                         ",t~" rspec-find-spec-or-target-find-example-other-window
                         ",t TAB" rspec-find-spec-or-target-other-window))))

  (defun ruby/inf-ruby-config ()
    (mmap rspec-compilation-mode-map ",td" 'inf-ruby-switch-from-compilation))
    ;; (add-hook 'rspec-compilation-mode-hook
    ;;           (lambda ()
    ;;             (interactive)
    ;;             (set (make-local-variable 'compilation-scroll-output) t)
    ;;             (set (make-local-variable 'scroll-margin) 2)))))

  (defun ruby/popwin-config ()
    (push '("*rspec-compilation*" :position bottom :stick t :noselect t :height 0.4)
          popwin:special-display-config))

  (dolist (hook '(ruby-mode-hook enh-ruby-mode-hook))
    (add-hook hook (lambda ()
                     (interactive)
                     (popwin-mode t)
                     (company-mode t))))
#+END_SRC

Robe has a nice function to start it, but not one to stop it. Naively killing
the buffer can lead to issues on Mac OS, so here's a function to nicely kill
Robe's ruby process and buffer.
#+BEGIN_SRC emacs-lisp
(defun robe-stop ()
  (interactive)
  (let* ((buffer (robe-inf-buffer))
         (process (get-buffer-process buffer)))
    (when process (delete-process process))
    (when buffer (kill-buffer buffer))))
#+END_SRC
*** TODO YAML
** Software support
*** TODO Org mode
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)

(defun bvn/org-mode-hook ()
  (setq fill-column 80)
  (auto-fill-mode t))

(add-hook 'org-mode-hook 'bvn/org-mode-hook)
#+END_SRC
**** Keybindings
Evil has some keybindings that conflict with org mode. Fix them.
#+BEGIN_SRC emacs-lisp
(defun bvn/org-mode-bindings ()
  (nmap nil "TAB" 'org-cycle))
(add-hook 'org-mode-hook 'bvn/org-mode-bindings)
#+END_SRC
** Everything so far, which isn't a lot
#+BEGIN_SRC emacs-lisp
(nmap nil ",ll" 'eval-last-sexp)
#+END_SRC
*** Move custom to its own file
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'noerror)
#+END_SRC
*** Syntax highlighting in org code blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC
** Load packages
#+BEGIN_SRC emacs-lisp
(bvn/load-packages)
#+END_SRC
