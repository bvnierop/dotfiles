#+TITLE: Emacs configuration file
#+AUTHOR: Bart van Nierop

* Config
** TODOS
*** TODO REWRITE TO STRAIGHT
**** Ensure EVIL is always available (so we don't have to use-feature evil all the time)
**** Ensure General is always available
*** TODO Bindings
https://github.com/magit/magit/issues/1968
*** TODO Run through Vim config
**** TODO plugins
***** DONE Commentary
***** DONE Dispatch (not needed)
***** DONE Surround
***** DONE Sleuth (could be solved with local configs)
See: dtrt-indent
***** DONE CtrlP (Helm / Projectile)
***** TODO YouCompleteMe (autocompletion / company + providers)
***** TODO Search (ack/ag)
***** TODO Fugitive (Magit)
***** TODO Slimv (Slime)
***** TODO Jsx
***** TODO Ragtag (html editing)
***** TODO Ale (flycheck?)
***** TODO Tmux
*** TODO Open special windows in a normal place
*** TODO Autocomplete
**** TODO Set proper backends everywhere (not _just_ for the language, also for filenames etc)
*** TODO Indent size, spaces, etc.
*** TODO Layout management / tmux / screen
*** TODO Language support
*** TODO Magit
*** TODO Hydra
https://github.com/abo-abo/hydra
*** TODO Line width
*** TODO Helm open buffer with <RET>?
*** TODO Company don't complete with <RET>
*** TODO Open/find file under cursor (ffap)
*** TODO Random stuff
**** Don't generate *scratch* instructions
** Utility functions
*** Lexical binding
Since Emacs 24, Emacs Lisp supports lexical binding. Since this makes lisp much
more powerful, we enable it.
#+BEGIN_SRC emacs-lisp
(setq lexical-binding t)
#+END_SRC
*** List helpers
#+BEGIN_SRC emacs-lisp
(defun bvn/add-to-list (target-list val &rest values)
  (while val
    (add-to-list target-list val)
    (setq val (pop values))))
#+END_SRC
*** Function helpers
The function below helps us find functions that have a certain suffix
as name. The goal is to support dynamic configuration of plugins.
#+BEGIN_SRC emacs-lisp
(defun find-functions-with-suffix (suffix)
  (let ((functions nil))
    (mapatoms (lambda (a)
                (when (and (fboundp a)
                           (string-suffix-p suffix (symbol-name a)))
                  (push a functions))))
    functions))
#+END_SRC
It is used like this:
(defun foobarbaz-config ()
  (mapc 'funcall
        (functions-with-suffix "/foobarbaz-config")))

(defun ruby/foobarbaz-config ()
  (interactive)
  (message "called!"))
*** OS helpers
The following macros only execute their body on the given operating system.
#+BEGIN_SRC emacs-lisp
  (defmacro bvn/on-windows (&rest body)
    `(if (eq system-type 'windows-nt)
         (progn ,@body)))

  (defmacro bvn/on-mac (&rest body)
    `(if (eq system-type 'darwin)
         (progn ,@body)))

  (defmacro bvn/on-terminal (&rest body)
    `(unless window-system
       (progn ,@body)))

  (defmacro bvn/on-gui (&rest body)
    `(when window-system
       (progn ,@body)))
#+END_SRC
*** Mode helpers
An easy way to enable many minor modes for many major modes all at once
#+BEGIN_SRC emacs-lisp
(defun enable-minor-modes (modes &keyword for)
  "Add a hook to enable minor modes on a mode switch"
  (cl-flet ((mklist (inp) (if (atom inp) (list inp) inp)))
    (let ((hooks (mapcar (lambda (mode)
                           (intern (concat (symbol-name mode) "-hook")))
                         (mklist for))))
      (mapcar (lambda (hook)
                (mapcar (lambda (mode) (add-hook hook mode)) (mklist modes)))
              hooks))))
#+END_SRC
** Setting up the package manager
I use [[https://github.com/raxod502/straight.el][straight.el]] for package management, because it produces a deterministic
output and can take packages from git.

Also, ~package.el~ often modifies ~custom.el~ and uses that as the basis for
which packages to load, as opposed to looking at my use of ~use-package~.

Finally, updating with ~package.el~ is a hassle. I'm hoping it's easier with
~straight.el~.

First, we need to bootstrap it.
#+BEGIN_SRC emacs-lisp
;; (defvar bootstrap-version)
;; (let ((bootstrap-file
;;        (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
;;       (bootstrap-version 5))
;;   (unless (file-exists-p bootstrap-file)
;;     (with-current-buffer
;;         (url-retrieve-synchronously
;;          "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
;;          'silent 'inhibit-cookies)
;;       (goto-char (point-max))
;;       (eval-print-last-sexp)))
;;   (load bootstrap-file nil 'nomessage))
#+END_SRC

I do want to continue to use ~use-package~, but we now need to load it in
another way
#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC

I'll tell ~use-package~ to always install a package using ~straight.el~ unless
told otherwise.
#+BEGIN_SRC emacs-lisp
(setq straight-use-package-by-default t)
#+END_SRC

I'm also always deferring loading, unless told otherwise using the ~:demand~ keyword.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t)
#+END_SRC

I do want to keep ~package.el~ for browsing packages on MELPA.
#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)
#+END_SRC

For configuring the packges, we have a few helpers. These make it obvious what
each invocation of ~use-package~ does.
#+BEGIN_SRC emacs-lisp
(defmacro ensure-package (package-name &rest args)
"Macro to ensure that a package is loaded. Every package that is used,
must at some point be installed using this macro."
  (declare (indent defun))
  `(use-package ,package-name
     ,@args))

(defmacro use-feature (package-name &rest args)
  "Macro to configure certain packages"
  (declare (indent defun))
  `(use-package ,package-name
     :straight nil
     ,@args))

(defmacro ensure-packages (&rest package-names)
  "Ensure that multiple packages are loaded"
  (declare (indent defun))
  `(progn
     ,@(mapcar (lambda (pkg) `(ensure-package ,pkg :demand t)) package-names)))
#+END_SRC

** Evil
It is said that Emacs is an awesome operating system, lacking only a decent text
editor. [[https://github.com/emacs-evil/evil][Evil-mode]] changes that, bringing modal editing to Emacs.
#+BEGIN_SRC emacs-lisp
  (ensure-package evil
    :demand t
    :init
            (setq evil-want-C-u-scroll t)
            (bvn/on-terminal
             (setq evil-want-C-i-jump nil)) ; Allow tabs in terminal
            (setq evil-want-C-w-in-emacs-state t) ; Allow window navigation in emacs state
    :config (evil-mode t))
#+END_SRC

For our keybinding needs, we'll use general.el

#+BEGIN_SRC emacs-lisp

#+END_SRC
*** Keybinding helpers
We like Vim style keybindings. These functions help.
#+BEGIN_SRC emacs-lisp
(defun kbd-or-fn (input)
  "Return the keyboard encoded sequence if input is a string. Otherwise, return the input, assuming it's a function."
  (if (stringp input)
      (kbd input)
    input))

(defun gmap (keys action)
  "Map keys to an action using `global-set-key`."
  (global-set-key (kbd keys) (kbd-or-fn action)))

(defun fmap (keybind-fn keys action)
  "Map keys to an action using `keybind-fn`."
  (call keybind-fn (kbd keys) (kbd-or-fn action)))

(defun xmap (keymap keys action &rest bindings)
  "Map keys to an action in the given `keymap`."
  (while keys
    (define-key keymap (kbd keys) (kbd-or-fn action))
    (setq keys (pop bindings)
          action (pop bindings))))

(defun xmap-keymap (state keymap keys action &rest bindings)
  "Map keys to an action in the given `keymap`."
  (while keys
    (evil-define-key state keymap (kbd keys) (kbd-or-fn action))
    (setq keys (pop bindings)
          action (pop bindings))))

(defun nmap (keymap keys action &rest bindings)
  "Map keys to an action in evil normal state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'normal keymap keys action bindings)
    (apply 'xmap evil-normal-state-map keys action bindings)))

(defun imap (keymap keys action &rest bindings)
  "Map keys to an action in evil insert state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'insert keymap keys action bindings)
    (apply 'xmap evil-insert-state-map keys action bindings)))

(defun vmap (keymap keys action &rest bindings)
  "Map keys to an action in evil visual state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'visual keymap keys action bindings)
    (apply 'xmap evil-visual-state-map keys action bindings)))

(defun mmap (keymap keys action &rest bindings)
  "Map keys to an action in evil motion state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'motion keymap keys action bindings)
    (apply 'xmap evil-motion-state-map keys action bindings)))

(defun emap (keymap keys action &rest bindings)
  "Map keys to an action in evil emacs state. if KEYMAP is provided, the binding
is only active when that keymap is active."
  (if keymap
      (apply 'xmap-keymap 'emacs keymap keys action bindings)
    (apply 'xmap evil-emacs-state-map keys action bindings)))
#+END_SRC

For many things in the minibuffer we like to change the behaviour of C-w and
C-r. This macro helps.
#+BEGIN_SRC emacs-lisp
(defmacro bvn/vimify-minibuffer (mode)
  `(xmap ,mode
         "C-w" 'evil-delete-backward-word
         "C-r" 'evil-paste-from-register))
#+END_SRC

*** Cleaning some keys
Use TAB to be, well, TAB.
#+BEGIN_SRC emacs-lisp
(gmap "TAB" 'self-insert-command)
#+END_SRC

Don't bind anything to backslash, space or comma. Yes, comma is something in
Vim, but I never use it, and do use it for my leader key.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil "\\" nil
                     "," nil
                     "SPC" nil)))
#+END_SRC
*** Command aliases
Ex commands are better when they're short
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "sus" 'suspend-emacs)
#+END_SRC
*** Cursor movement
In Vim I've made some changes to the way j and k work. I want them to move over
visual lines, not actual ones.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil  "j" evil-next-visual-line
                      "k" evil-previous-visual-line)))
#+END_SRC
Another change I've made in Vim is that C-u and C-d simply move the cursor, and
not the screen. This makes them usefull to jump a sizable distance, making it
easy to navigate a file. It's not truly the Vim way, but works just fine for me.
#+BEGIN_SRC emacs-lisp
(dolist (mapfn '(nmap vmap mmap))
  (apply mapfn '(nil "C-u" "20k"
                     "C-d" "20j")))
#+END_SRC
Because C-u is actually quite important in Emacs, we need to remap it.
#+BEGIN_SRC emacs-lisp
(gmap "M-C-U" 'universal-argument)
#+END_SRC

*** Commentary
Having an easy way to comment out lines is pretty awesome.
#+BEGIN_SRC emacs-lisp
(ensure-package evil-commentary
  :demand t
  :config (setq evil-commentary-mode t))
  
#+END_SRC
*** Surround
Vim-surround is one of Tim Pope's more useful plugins. And that says something.
#+BEGIN_SRC emacs-lisp
(ensure-package evil-surround
  :demand t
  :config (global-evil-surround-mode 1))
#+END_SRC
*** Undo
Evil has various way to deal with undo-redo. We'll use ~undo-tree~.
#+begin_src emacs-lisp
(ensure-package undo-tree
  :demand t
  :config
  (global-undo-tree-mode 1)
  (use-feature evil
    :config
    (evil-set-undo-system 'undo-tree)))
#+end_src
** Vimify
Some things, we really want just like in vim...

For starters, C-w and C-r.
#+BEGIN_SRC emacs-lisp
(gmap "C-w" 'evil-delete-backward-word)
(gmap "C-r" 'evil-paste-from-register)
; (xmap 'overriding-terminal-local-map "C-w" nil)
; (xmap 'overriding-terminal-local-map "C-r" nil)
#+END_SRC

This covers most cases, except for... isearch. Isearch is weird. It does not use
the minibuffer for text entry. It doesn't use a buffer, at all. 'Normal' text
editing is not a thing in Isearch. Because of that, we need to do some magic.

~isearch-kill-last-word~ deletes the last word in the search. On its own,
however, this isn't enough. Pressing ~DEL~ or ~BACKSPACE~ would /undo/ this
instead of deleting the next /last/ character, because ~isearch-delete-char~
undoes the last operation (which was to delete the last word).
#+BEGIN_SRC emacs-lisp
(defun isearch-kill-last-word ()
  (interactive)
  (setq isearch-suspended t)
   (with-temp-buffer
     (insert isearch-string)
     (backward-kill-word 1)
     (isearch-resume (buffer-string)
                     isearch-regexp
                     isearch-word
                     isearch-forward
                     (buffer-string)
                     isearch-case-fold-search)))

(defun isearch-kill-last-char ()
  (interactive)
  (setq isearch-suspended t)
   (with-temp-buffer
     (insert isearch-string)
     (backward-delete-char 1)
     (isearch-resume (buffer-string)
                     isearch-regexp
                     isearch-word
                     isearch-forward
                     (buffer-string)
                     isearch-case-fold-search)))

(xmap isearch-mode-map "C-w" 'isearch-kill-last-word)
(xmap isearch-mode-map "<DEL>" 'isearch-kill-last-char)
(xmap isearch-mode-map "<backspace>" 'isearch-kill-last-char)
#+END_SRC

C-g is the emergency escape in Emacs. I'd like it to also go into normal state
from insert state, since that cannot be moved to C-c.
#+BEGIN_SRC emacs-lisp
(imap nil "C-g" (lambda ()
                  (interactive)
                  (evil-normal-state)
                  (keyboard-quit)))
#+END_SRC
** Basic configuration
*** Keep modeline clean
The modeline gets pretty cluttered with all the minor modes enhancing Emacs
experience. In order to clean it up, I use blackout.

This allows me to add ~:blackout t~ to ~use-package~ definitions.
#+BEGIN_SRC emacs-lisp
(ensure-package blackout
  :straight (:host github :repo "raxod502/blackout")
  :demand t)
#+END_SRC
*** Colorize compilation buffer
The ~*compilation*~ is not colorized by default. We want it to support ANSI
coloring.
#+begin_src emacs-lisp
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (ansi-color-apply-on-region compilation-filter-start (point)))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+end_src
*** Color scheme
Gruvbox is the best color scheme, hands down.
#+BEGIN_SRC emacs-lisp
(ensure-package gruvbox-theme
  :demand t
  :config
  (load-theme 'gruvbox t))
#+END_SRC
*** Various quality of life settings
Don't show the startup screen.
#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
#+end_src

Shut up Emacs
#+begin_src emacs-lisp
  (setq visible-bell nil
        ring-bell-function (lambda ()))
#+end_src

Show matching parentheses.
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode 1)
#+END_SRC

Use line numbers.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode t)
#+END_SRC

Show column numbers in the mode line
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

No cursor blinking
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

Indentation. Electric indent mode makes sure that when starting a new line,
enough whitespace is inserted. Inhibit ensures that only the /new/ line is
indented, while the previous line is left alone. This prevents Emacs from
messing up custom indentation, which is sometimes needed.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq-default electric-indent-mode t)
(setq-default electric-indent-inhibit t)
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
(setq tab-stop-list (number-sequence tab-width 200 tab-width))
#+END_SRC

Use UTF-8 as the default file encoding.
#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

Automatically reload files changed files.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC

End all files with a newline
#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline t)
#+END_SRC

Highlight the current line.
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC
 
Store backups in a more central place.
#+BEGIN_SRC emacs-lisp
(defun bvn/generate-backup-file-name (file-path)
  "Generate and return a better file path for backups"
  (let* ((backup-root-dir "~/.emacs.d/tmp/")
         (sanitized-file-path (replace-regexp-in-string
                               "\\\\" "/" (replace-regexp-in-string
                                         "^\\([A-Za-z]\\):" "\\1/" file-path)))
         (full-file-path (replace-regexp-in-string
                          "//" "/" (concat backup-root-dir sanitized-file-path "~"))))
    (make-directory
     (file-name-directory full-file-path)
     (file-name-directory full-file-path))
    full-file-path))

(setq make-backup-file-name-function 'bvn/generate-backup-file-name
      backup-by-copying t)
#+END_SRC

Store auto saves in a more central place
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms
  '((".*" "~/.emacs.d/tmp/" t)))
#+END_SRC
Do not create lock files.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

Keep some space when scrolling. Also, scrolling 1 row or column at a time is nicer.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 8)
(setq scroll-step 1)
(setq hscroll-margin 16)
(setq hscroll-step 1)
#+END_SRC

When splitting windows, keep some minimum space that makes sense. Preferably, I
want to be able to see at least 120 columns and at least 80 lines. This should
fit most code and paragraphs in a split.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold 160
      split-width-threshold 240)
#+END_SRC

Disable GUI fluff.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Set a slightly larger font. `set-face-attribute` already does nothing in
terminal Emacs, but it doesn't hurt to be specific.
#+BEGIN_SRC emacs-lisp
  (bvn/on-gui
   (set-face-attribute 'default nil :height 100))

  (bvn/on-mac
   (bvn/on-gui
    (set-face-attribute 'default nil :height 140)))
#+END_SRC

Do not store undo-tree files everywhere.
#+BEGIN_SRC emacs-lisp
(setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
#+END_SRC
*** Automatically detect indent settings
dtrt-indent is like vim-sleuth, but for Emacs. It detects the indent settings of the current file.
Apparently, it's not on melpa-stable.
#+BEGIN_SRC emacs-lisp
(ensure-package dtrt-indent
  :demand t)
#+END_SRC
*** Helm
#+BEGIN_SRC emacs-lisp
  (ensure-package helm
    :defer t
    :config
    (helm-mode t)
    (setq helm-autoresize-mode t
          helm-follow-mode-persistent t)
    (gmap  "M-x" 'helm-M-x)
    (bvn/vimify-minibuffer helm-map)
    (dolist (mapfn '(nmap mmap))
      (apply mapfn '(nil ",fm" helm-mini
                         ",fe" helm-find-files))))
#+END_SRC

*** Free keys
#+BEGIN_SRC emacs-lisp
(ensure-package free-keys
  :defer t)
#+END_SRC
** Key bindings
which-key helps with discovery.
#+BEGIN_SRC emacs-lisp
(ensure-package which-key
  :demand t
  :config
    (setq which-key-idle-delay 0.5)
    (which-key-mode +1)
  :blackout t)
#+END_SRC
** Eldoc
#+begin_src emacs-lisp
  (ensure-package eldoc :demand t)
#+end_src

By default ~eldoc~ displays documentation in the minibuffer. This is annoying to
me. So we disable it.
#+begin_src emacs-lisp
  (setq eldoc-echo-area-prefer-doc-buffer t)
#+end_src
** Window layout
*** Purpose
Use [[https://github.com/bmag/emacs-purpose][window-purpose]] to set up Emacs windows in a useful way. This is work in
progress.
#+begin_src emacs-lisp
  ;; (ensure-package window-purpose
  ;;   :demand t
  ;;   :config (purpose-mode t)

  ;;   (defun bvn/purpose-clear-user-config ()
  ;;     (setq purpose-user-mode-purposes nil
  ;;           purpose-user-name-purposes nil
  ;;           purpose-user-regexp-purposes nil)
  ;;     (purpose-compile-user-configuration))

  ;;   (defun bvn/purpose-setup-layout ()
  ;;     (delete-other-windows)
  ;;     (purpose-set-window-purpose-dedicated-p nil nil) ; clears dedication of the current window

  ;;     (purpose-set-window-purpose 'edit)

  ;;     (split-window-right -80) ; Sets up the window on the right
  ;;     (other-window 1)

  ;;     (purpose-set-window-purpose 'documentation)

  ;;     (split-window-below) ; Sets up the bottom right
  ;;     (other-window 1)

  ;;     (purpose-set-window-purpose 'temporary)

  ;;     (other-window 1)) ; Go back to edit window

  ;;   (defun bvn/purpose-create-user-config (modes names regexps)
  ;;     (setq purpose-user-mode-purposes modes
  ;;           purpose-user-name-purposes names
  ;;           purpose-user-regexp-purposes regexps)
  ;;     (purpose-compile-default-configuration)
  ;;     (purpose-compile-user-configuration))

  ;;   (defun bvn/purpose-setup ()
  ;;     (interactive)
  ;;     (bvn/purpose-create-user-config
  ;;      '((magit-mode . edit)
  ;;        (org-agenda-mode . temporary))
  ;;      '(("*eldoc*" . documentation)
  ;;        ("*Racket Describe*" . documentation)
  ;;        ("*Org Agenda*" . temporary)
  ;;        ("*scratch*" . edit))
  ;;      '(("^ *\\*.+\\* *$" . temporary)))
  ;;     (when (>= (frame-width) 180)
  ;;       (bvn/purpose-setup-layout)))

  ;;   (add-hook 'window-setup-hook 'bvn/purpose-setup)
  ;;   (add-hook 'server-after-make-frame-hook 'bvn/purpose-setup))
#+end_src

*** Popup windows
We may not use this much longer. We might switch to Shackle or let
window-purpose solve most of our problems.
#+BEGIN_SRC emacs-lisp
(ensure-package popwin
  :demand t
  :config
  (dolist (mapfn '(nmap mmap))
    (apply mapfn '(nil ",wq" popwin:close-popup-window))))
  (setq popwin:popup-window-height 0.3)
  (popwin-mode 1)
#+END_SRC

This section defines helpers for popup windows. At this point I'm still looking
for a good window management/popup window solution. Instead of having to change
all my setup for all languages all of the time, this section defines some
helpers to use instead.

We start with a macro to replace ~use-feature~. Instead of ~(use-feature popwin
...)~ or whatever the flavour of the month is, I want to use something along the
lines of ~(popup:configure ...)~ that automagically contains ~(use-feature
...)~. If we then change from ~popwin~ to, say, ~popper~, all that has to be
changed is the macro.

#+BEGIN_SRC emacs-lisp
  (defun popup::make-push-statement (statement)
    `(push (quote ,statement) popwin:special-display-config))

  (defmacro popup:configure (options)
    "Macro to configure popups"
    (declare (indent defun))
    `(use-feature popwin
       :config (progn ,@(mapcar #'popup::make-push-statement options))))
#+END_SRC
** Compilation
*** Strip leading/trailing whitespace from file names
Sometimes the file names detected by compilation mode are slightly wrong. They
may contain leading whitespace. We want to strip that so that we can easily jump
to the correct files.
#+begin_src emacs-lisp
  (require 'compile)
  (add-to-list 'compilation-transform-file-match-alist '("^[[:blank:]]+\\(.+\\)[[:blank:]]*" "\\1"))
#+end_src
** File navigation
Projectile is the package we use to deal with projects. We use helm-projectile to
integrate with helm.

Some things are best left alone. Therefore we ignore a bunch of files when
searching with Projectile.
#+BEGIN_SRC emacs-lisp
(ensure-package projectile
  :demand t
  :config
  (use-feature evil
    :config
    (evil-ex-define-cmd "ps" 'projectile-run-eshell)
    (nmap nil
    ",ps" 'projectile-run-eshell
    ",pt" 'projectile-test-project
    ",pr" 'projectile-run-project
    ",pc" 'projectile-compile-project
    ",pd" 'projectile-run-shell-command-in-root
    ",ft" 'projectile-find-test-file
    "\\]" 'projectile-toggle-between-implementation-and-test
    ))

  (ensure-package helm-projectile
    :demand t
    :config
    (use-feature evil
      :config
      (dolist (mapfn '(nmap mmap))
        (apply mapfn '(nil ",ff" helm-projectile-find-file
                           ",fp" helm-projectile-switch-project))))

    (bvn/add-to-list 'projectile-globally-ignored-directories
                     ".git" ".hg" ".svn"
                     ".yardoc"
                     "public/images" "public/system" "data" "log" "tmp" "debug" "release"
                     "node_modules" "vendor" "quicklisp"
                     "_build"
                     ".merlin")

    (bvn/add-to-list 'projectile-globally-ignored-file-suffixes
                     ".exe" ".so" ".a" ".d" ".dll" ".o" ".fasl"
                     ".log" ".tlog"
                     ".dat"
                     ".sdf" 
                     ".pdf"
                     ".bcmap"
                     ".png" ".jpg" ".jpeg" ".svg"))
  (projectile-mode t))
#+END_SRC

One thing I did in vim was map switching between two buffers to \\
#+BEGIN_SRC emacs-lisp
(nmap nil "\\\\" 'evil-switch-to-windows-last-buffer)
(mmap nil "\\\\" 'evil-switch-to-windows-last-buffer)
#+END_SRC

** Search
#+BEGIN_SRC emacs-lisp
(ensure-package helm-ag
  :demand t
  :config
  (nmap nil ",sa" 'helm-ag-project-root
        ",sf" 'helm-ag-this-file
        ",sd" 'helm-do-ag-project-root))
#+END_SRC
** Source control
#+BEGIN_SRC emacs-lisp
(ensure-package magit
  :demand t
  :config
  (nmap nil ",gs" 'magit-status
            ",gb" 'magit-blame
            ",gB" 'magit-blame-quit
            ",gS" 'magit-stage-file
            ",gU" 'magit-unstage-file
            ",gl" 'magit-log
            ",gr" 'magit-rebase
            ",gd" 'magit-diff))
#+END_SRC

** Language support
*** TODO General
**** Auto completion
The common auto-complete front-end to Emacs is company-mode. Because company uses C-w
for 'show-location', and I want to use it to kill the previous word, the binding is removed.
It's bound to C-l instead.
#+BEGIN_SRC emacs-lisp
(ensure-package company
  :demand
  :config
  (xmap company-active-map
        "C-w" nil
        "C-l" 'company-show-location
        "C-n" 'company-select-next
        "C-p" 'company-select-previous
        "TAB" 'company-complete-common-or-cycle
        "ESC" 'company-abort))

(defun company/set-backend (backend)
  (set (make-local-variable 'company-backends) (list backend 'company-semantic 'company-files)))
#+END_SRC

We're going to be using different completion engines for different
languages. Each of these will be set up individually in their
languages heading.
**** Syntax checking
#+BEGIN_SRC emacs-lisp
(ensure-package flycheck
  :demand t
  :config
  (nmap nil ",cl" 'flycheck-list-errors
        ",cn" 'flycheck-next-error
        ",cp" 'flycheck-previous-error)
    :config
    (popup:configure
      (("*Flycheck errors*" :position bottom :stick t :noselect t :height 0.4))))
#+END_SRC
**** LSP
Language Server Protocol support makes it easy to add IDE-like integration for
many languages.
#+BEGIN_SRC emacs-lisp
(ensure-package eglot
  :demand t)
#+END_SRC

Because language servers throw a lot of output at Emacs, we need to make some
changes to prevent Emacs from slowing down to a crawl.
#+begin_src emacs-lisp
  (use-feature eglot
    :config
    (setq gc-cons-threshold (* 50 1024 1024)
          read-process-output-max (* 1024 1024)))
#+end_src
*** TODO C#
**** Base setup
#+begin_src emacs-lisp
  (ensure-package csharp-mode
    :demand t)

  (use-feature csharp-mode
    :config
    (use-feature company
      :hook (csharp-mode . company-mode))
    (use-feature eglot
      :hook (csharp-mode . eglot-ensure)
      :config
      (nmap csharp-mode-map
            ",caa" 'eglot-code-actions
            ",cai" 'eglot-code-action-inline
            ",cae" 'eglot-code-action-extract))
    (use-feature flycheck))
#+end_src
**** Omnisharp-roslyn hack
#+begin_src emacs-lisp
  (use-feature eglot
    :config
    (defgroup eglot-csharp nil
      "LSP support for the csharp programming language, using omnisharp-roslyn."
      :group 'eglot)

    (defcustom eglot-csharp-install-dir
      (locate-user-emacs-file "omnisharp-roslyn/")
      "Install directory for omnisharp-roslyn."
      :group 'eglot-csharp
      :type 'directory)

    (defcustom eglot-csharp-version
      nil
      "Force a certain version of omnisharp-roslyn"
      :group 'eglot-csharp
      :type 'string)

    (defun eglot-csharp--version-file ()
      "Return the full path of the omnisharp-roslyn version file."
      (expand-file-name (concat eglot-csharp-install-dir ".version")))

    (defun eglot-csharp--server-file ()
      "Return the full path of the omnisharp-roslyn server."
      (expand-file-name (concat eglot-csharp-install-dir "run")))

    (defun eglot-csharp--zip-file ()
      "Return the full path of the omnisharp-roslyn server."
      (expand-file-name (concat eglot-csharp-install-dir "omnisharp-roslyn.zip")))

    (defvar eglot-csharp-github-version nil
      "The latest version number of omnisharp-roslyn")

    (defun eglot-csharp--fetch-github-version ()
      "Retun the latest version of omnisharp-roslyn"
      (or eglot-csharp-github-version
          (with-temp-buffer
            (condition-case err
                (let ((json-object-type 'hash-table)
                      (url-mime-accept-string "application/json"))
                  (url-insert-file-contents "https://github.com/OmniSharp/omnisharp-roslyn/releases/latest")
                  (goto-char (point-min))
                  (setq eglot-csharp-github-version (gethash "tag_name" (json-read))))
              (file-error
               (warn "omnisharp-roslyn version check: %s" (error-message-string err)))))))

    (defun eglot-csharp--requested-version ()
      (if eglot-csharp-version
          eglot-csharp-version
        (eglot-csharp--fetch-github-version)))

    (defun eglot-csharp--install (version)
      "Downloads VERSION of omnisharp-roslyn and install in `eglot-csharp-install-dir'"

      (let ((url (format "https://github.com/OmniSharp/omnisharp-roslyn/releases/download/%s/omnisharp-linux-x64.zip"
                         version))
            (zip (eglot-csharp--zip-file)))
        (make-directory eglot-csharp-install-dir t)
        (message "eglot-csharp: Downloading %s" url)
        (url-copy-file url zip t)
        (let ((default-directory eglot-csharp-install-dir))
          (message "eglot-csharp: Unzipping into %s" eglot-csharp-install-dir)
          (if (zerop (call-process "unzip" nil nil nil "-o" zip))
              (with-temp-file (expand-file-name (concat eglot-csharp-install-dir ".version"))
                (insert version))
            (error "Failed to unzip %s" zip))))
      (message "eglot-csharp: Setting execute permissions")
      (call-process "chmod" nil nil nil "+x" (eglot-csharp--server-file)))

    (defun eglot-csharp--installed-version ()
      "Return the version string of omnisharp-roslyn"
      (condition-case err
          (with-temp-buffer
            (insert-file-contents (eglot-csharp--version-file))
            (buffer-string))
        (file-error nil)))

    (defun eglot-csharp--up-to-date-p ()
      "Return t if the current installation is up to date."
      (equal (eglot-csharp--requested-version) (eglot-csharp--installed-version)))

    (defun eglot-csharp--ensure ()
      "Ensures the latest version of omnisharp-roslyn is installed."
      (unless (eglot-csharp--up-to-date-p)
        (eglot-csharp--install (eglot-csharp--fetch-github-version))))

  ;;;###autoload
    (defun eglot-csharp (interactive)
      "Return eglot contact when omnisharp-roslyn is installed. Automagically installs
  omnisharp-roslyn when called INTERACTIVE."
      (when interactive
        (eglot-csharp--ensure))
      (if (file-exists-p (eglot-csharp--server-file))
          `(eglot-omnisharp-roslyn ,(eglot-csharp--server-file)
                                   "-lsp"
                                   "--source"
                                   ,(projectile-project-root))
        (warn "eglot-csharp: omnisharp-roslyn is missing. Execute `M-x eglot` in an csharp buffer to install it.")))

    (defclass eglot-omnisharp-roslyn (eglot-lsp-server) ()
      :documentation "lsp server csharp based on omnisharp-roslyn")

    (add-to-list 'eglot-server-programs `(csharp-mode . eglot-csharp)))
#+end_src
*** TODO C++
*** TODO Common Lisp
**** Language support
#+BEGIN_SRC emacs-lisp
(ensure-package slime
  :demand t
  :init
  (setq slime-complete-symbol*-fancy t)
  :config 
  (use-feature evil
    :config
    (dolist (map-fn '(nmap vmap mmap))
      (apply map-fn lisp-mode-map
             '(",'"  qlot-slime-start

               ",cc" slime-compile-file
               ",cC" slime-compile-and-load-file
               ",cl" slime-load-file
               ",cf" slime-compile-defun
               ",cr" slime-compile-region
               ",cn" slime-remove-notes

               ",eb" slime-eval-buffer
               ",ef" slime-eval-defun
               ",eF" slime-undefine-function
               ",ee" slime-eval-last-expression
               ",er" slime-eval-region

               ",gb" slime-pop-find-definition-stack
               ",gn" slime-next-note
               ",gN" slime-previous-note

               ",ha" slime-apropos
               ",hA" slime-apropos-all
               ",hd" slime-disassemble-symbol
               ",hh" slime-describe-symbol
               ",hH" slime-hyperspec-lookup
               ",hi" slime-inspect-definition
               ",hp" slime-apropos-package
               ",ht" slime-toggle-trace-fdefinition
               ",hT" slime-untrace-all
               ",h<" slime-who-calls
               ",h>" slime-calls-who

               ",hr" slime-who-references
               ",hm" slime-who-macroexpands
               ",hs" slime-who-specializes

               ",ma" slime-macroexpand-all
               ",mo" slime-macroexpand-1

               ",se" slime-eval-last-expression-in-repl
               ",si" qlot-slime-start
               ",sq" slime-quit-lisp

               ",tf" slime-toggle-fancy-trace)))))
(ensure-package paredit :demand t)

  (defun qlot-slime-start ()
    (interactive)
    (let ((directory (projectile-project-root)))
      (slime-start :program "qlot"
                   :program-args '("exec" "ros" "-S" "." "run" "--" "--dynamic-space-size" "4096")
                   :directory directory
                   :name 'qlot
                   :env (list (concat "PATH="
                                      (mapconcat 'identity exec-path ":"))
                              (concat "QUICKLISP_HOME="
                                      (file-name-as-directory directory) "quicklisp/")))))
#+END_SRC	
**** Auto complete
#+BEGIN_SRC emacs-lisp
(use-feature slime
  :config
  (ensure-package slime-company)
  :config
  (defun common-lisp/add-to-company ()
    (set (make-local-variable 'company-backends) '(company-slime)))
  (add-hook 'lisp-mode-hook
            (lambda ()
              (interactive)
              (common-lisp/add-to-company)
              (company-mode t))))
#+END_SRC
*** TODO CSS
*** TODO Elixir
#+BEGIN_SRC emacs-lisp
  (ensure-package elixir-mode
    :demand t
    :config
    (ensure-package company)
    (ensure-package eglot
      :config
      (add-hook 'elixir-mode-hook 'eglot-ensure)
      (ensure-package eglot-elixir
        :straight (:host github :repo "bvnierop/eglot-elixir")
        :demand t))

    (ensure-package alchemist
      :after company)
    (add-hook 'elixir-mode-hook
              (lambda ()
                (interactive)
                (alchemist-mode)
                (company/set-backend 'alchemist-company)
                (company-mode t)))
    (ensure-package flycheck
      :config
      (ensure-package flycheck-credo)))
#+END_SRC
	
*** TODO F#
#+BEGIN_SRC emacs-lisp
  (ensure-package eglot-fsharp
    :demand t)

  (ensure-package fsharp-mode
    :demand t
    :config
    (use-feature eglot-fsharp
      :config
      (require 'eglot-fsharp)
      (add-hook 'fsharp-mode-hook (lambda ()
                                    (interactive)
                                    (enable-minor-modes '(company-mode dtrt-indent-mode) :for 'fsharp-mode)
                                    (eglot-ensure)))))
#+END_SRC
*** TODO HTML
*** TODO Java
*** TODO Javascript
#+BEGIN_SRC emacs-lisp
(enable-minor-modes 'dtrt-indent-mode :for 'js-mode)
#+END_SRC
*** TODO Markdown
#+BEGIN_SRC emacs-lisp
(ensure-package markdown-mode
  :demand t
  :mode 
  (("\\.md" . markdown-mode)
   ("\\.markdown" . markdown-mode))
  :config
  (defun markdown-mode-hook/configure ()
    (setq fill-column 80)
    (auto-fill-mode t))

  (add-hook 'markdown-mode-hook 'markdown-mode-hook/configure))
#+END_SRC
*** TODO OCaml
#+BEGIN_SRC emacs-lisp
  (ensure-packages
    merlin
    ocp-indent
    utop
    tuareg)

  (defun ocaml/initialize-opam ()
    (if (executable-find "opam")
        (let* ((output (shell-command-to-string
                        "opam config var share 2> /dev/null"))
               (share (when (< 0 (length output))
                        (substring output 0 -1))))
          (when share
            (setq opam-share share
                  opam-load-path (concat share "/emacs/site-lisp"))
            (add-to-list 'load-path opam-load-path)))
      (message (concat "Cannot find \"opam\" executable. "
                       "OCaml language support won't work properly."))))

  (defun ocaml/merlin-locate ()
    (interactive)
    (let ((merlin-locate-in-new-window 'never))
      (merlin-locate)))

  (defun ocaml/merlin-locate-other-window ()
    (interactive)
    (let ((merlin-locate-in-new-window 'always))
      (merlin-locate)))

  (use-feature tuareg ; this is the ocaml mode
    :mode
    (("\\.ml[ily]?$" . tuareg-mode)
     ("\\.topml$" . tuareg-mode))

    :config
    ;; Merlin is for auto completion
    (use-feature merlin
      :hook (tuareg-mode . merlin-mode)
      :config
      (add-hook 'merlin-mode-hook
                (lambda ()
                  (interactive)
                  (setq merlin-completion-with-doc t)
                  (set (make-local-variable 'company-backends) '(merlin-company-backend))))

      (use-feature evil
        :config
        (nmap tuareg-mode-map
              ",cp" 'merlin-project-check
              ",cv" 'merlin-goto-project-file
              ",eC" 'merlin-error-check
              ",en" 'merlin-error-next
              ",eN" 'merlin-error-prev
              ",gb" 'merlin-pop-stack
              ",gG" 'ocaml/merlin-locate-other-window
              ",gl" 'merlin-locate-ident
              ",gi" 'merlin-switch-to-ml
              ",gI" 'merlin-switch-to-mli
              ",go" 'merlin-occurrences
              ",hh" 'merlin-document
              ",ht" 'merlin-type-enclosing
              ",hT" 'merlin-type-expr
              ",rd" 'merlin-destruct)))

    ;; We must do keybindings _after_ loading evil
    (ocaml/initialize-opam)
    (use-feature evil
      :config
      (nmap tuareg-mode-map
            ",ga" 'tuareg-find-alternate-file
            ",cc" 'projectile-compile-project))

    (use-feature utop
      :hook (tuareg-mode . utop-minor-mode)
      :config
      (setq utop-command "opam config exec -- utop -emacs")
      (use-feature evil
        :config
        (nmap tuareg-mode-map
              ",'"  'utop
              ",sb" 'utop-eval-buffer
              ",si" 'utop
              ",sp" 'utop-eval-phrase
              ",sr" 'utop-eval-region))))

                                          ;(defun ocaml/ocp-indent-config ()
                                          ;(add-hook 'tuareg-mode-hook 'ocp-indent-caml-mode-setup)
                                          ;(dolist (map-fn '(nmap vmap))
                                          ;(apply map-fn '(nil "=" ocp-indent-buffer))))
#+END_SRC
*** TODO Python
**** Language support
On Windows, we're likely to use the Python version chooser 'py'.
#+BEGIN_SRC emacs-lisp
(bvn/on-windows
  (setq python-shell-interpreter "py"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(ensure-package anaconda-mode
  :hook python-mode)
#+END_SRC
**** Auto completion
#+BEGIN_SRC emacs-lisp
(ensure-package company-anaconda
  :config
  (add-hook 'python-mode-hook
    (lambda () (add-to-list 'company-backends 'company-anaconda))))

  (defun python/add-to-company ()
    (add-to-list 'company-backends 'company-anaconda))
  (add-hook 'python-mode-hook 'python/add-to-company)
#+END_SRC
**** Syntax checking
*** TODO Racket
#+BEGIN_SRC emacs-lisp
  (ensure-package racket-mode
    :demand t
    :hook (racket-mode . racket-xp-mode)
    :config
    (ensure-package company
      :hook (racket-mode . company-mode))

    (use-feature evil
      :config
      (nmap racket-mode-map
            ;; errors
            ",En" 'racket-xp-next-error
            ",EN" 'racket-xp-previous-error
            ;; navigation
            ",g`" 'racket-unvisit
            ",gg" 'racket-xp-visit-definition
            ",gn" 'racket-xp-next-definition
            ",gN" 'racket-xp-previous-definition
            ",gm" 'racket-visit-module
            ",gr" 'racket-open-require-path
            ",gu" 'racket-xp-next-use
            ",gU" 'racket-xp-previous-use
            ;; doc
            ",ha" 'racket-xp-annotate
            ",hd" 'racket-xp-describe
            ",hh" 'racket-xp-documentation
            ;; insert
            ",il" 'racket-insert-lambda
            ;; refactor
            ",mr" 'racket-xp-rename
            ;; REPL
            ",'"  'racket-repl
            ",sb" 'racket-run
            ",sB" 'spacemacs/racket-run-and-switch-to-repl
            ",se" 'racket-send-last-sexp
            ",sE" 'spacemacs/racket-send-last-sexp-focus
            ",sf" 'racket-send-definition
            ",sF" 'spacemacs/racket-send-definition-focus
            ",si" 'racket-repl
            ",sr" 'racket-send-region
            ",sR" 'spacemacs/racket-send-region-focus
            ;; Tests
            ",tb" 'racket-test
            ",tB" 'spacemacs/racket-test-with-coverage)
      (imap racket-mode-map
            "C-a l" 'racket-insert-lambda)))

  (use-feature racket-mode
    :config
    (use-feature evil
      :config
      (nmap racket-repl-mode-map
            "C-w" nil
            "C-w C-w" 'evil-window-next)

      (imap racket-repl-mode-map
            "C-w" 'evil-delete-backward-word)
      ))
#+END_SRC
*** TODO Ruby
#+BEGIN_SRC emacs-lisp
(ensure-packages enh-ruby-mode
              robe
              rspec-mode)

(ensure-package enh-ruby-mode
  :demand t
  :mode
  (("Appraisals\\'" . enh-ruby-mode)
   ("\\(Rake\\|Thor\\|Guard\\|Gem\\|Cap\\|Vagrant\\|Berks\\|Pod\\|Puppet\\)file\\'" . enh-ruby-mode)
   ("\\.\\(rb\\|rabl\\|ru\\|builder\\|rake\\|thor\\|gemspec\\|jbuilder\\)\\'" . enh-ruby-mode))

  :config
  (setq enh-ruby-add-encoding-comment-on-save nil)

  (use-feature evil
    :config
    (require 'ruby-mode)
    (evil-define-motion evil-ruby-jump-item (count)
      :jump t
      :type inclusive
      (cond ((string-match ruby-block-beg-re (current-word))
             (enh-ruby-end-of-block count))
            ((string-match ruby-block-end-re (current-word))
             (enh-ruby-beginning-of-block count))
            (t (evil-jump-item count))))

    (add-hook 'enh-ruby-mode-hook
              (lambda ()
                (interactive)
                (nmap enh-ruby-mode-map "%" 'evil-ruby-jump-item)
                (mmap enh-ruby-mode-map "%" 'evil-ruby-jump-item))))

  (use-feature dtrt-indent
    :hook (enh-ruby-mode . dtrt-indent-mode))

  (use-feature robe
    :hook (enh-ruby-mode . robe-mode))

  (use-feature company
    :config
    (add-hook 'enh-ruby-mode-hook
              (lambda ()
                (interactive)
                (set (make-local-variable 'company-backends) '(company-robe))))
  :hook (enh-ruby-mode . company-mode))

  (use-feature flycheck
    :hook (enh-ruby-mode . flycheck-mode))

  (use-feature rspec-mode
    :config
    (setq rspec-use-spring-when-possible t)
    (setq rspec-autosave-buffer t)
    (use-feature evil
      :config
      (dolist (mapfn '(nmap mmap))
        (apply mapfn '(nil ",ta" rspec-verify-all
                           ",tb" rspec-verify
                           ",tc" rspec-verify-continue
                           ",tp" rspec-toggle-example-pendingness
                           ",tf" rspec-run-last-failed
                           ",tr" rspec-rerun
                           ",tt" rspec-verify-single
                           ",t~" rspec-find-spec-or-target-find-example-other-window
                           ",t TAB" rspec-find-spec-or-target-other-window
                           ",ti" comint-mode)))))
  (use-feature inf-ruby
    :config
    (use-feature evil
      :config
      (use-feature rspec-mode
        :config
        (mmap rspec-compilation-mode-map ",td" 'inf-ruby-switch-from-compilation))))

    (popup:configure
      (("*rspec-compilation*" :position bottom :stick t :noselect t :height 0.4))))
#+END_SRC

Robe has a nice function to start it, but not one to stop it. Naively killing
the buffer can lead to issues on Mac OS, so here's a function to nicely kill
Robe's ruby process and buffer.
#+BEGIN_SRC emacs-lisp
(defun robe-stop ()
  (interactive)
  (let* ((buffer (robe-inf-buffer))
         (process (get-buffer-process buffer)))
    (when process (delete-process process))
    (when buffer (kill-buffer buffer))))
#+END_SRC
*** TODO YAML
** Software support
*** TODO Org mode
The built-in org-mode is old. So we use a newer.
#+BEGIN_SRC emacs-lisp
  (use-feature org
    :config
    (require 'org-protocol)

    (setq org-startup-indented t
          org-src-fontify-natively t
          org-src-tab-acts-natively nil ; This causes src blocks to behave strangely when globally rebinding TAB (which I did)
          org-startup-folded t)

    (add-hook 'org-mode-hook (lambda () 
                               (setq fill-column 80)
                               (auto-fill-mode t)))

    (defun org-mode-indent-source ()
      (interactive)
      (org-edit-special)
      (evil-indent (point-min) (point-max))
      (org-edit-src-exit))

    (nmap nil ",=" 'org-mode-indent-source)
    (xmap org-mode-map "C-c l" 'org-store-link
          "C-c a" 'org-agenda))
#+END_SRC

org-protocol is amazing for capturing things such as interesting websites to
read. Unfortunately, org-capture doesn't quite behave the way I want it to in
combination with org-protocol. Specifically it hardcodes where the buffer should
be placed, rather than using ~display-buffer~. This is annoying for several
reasons, but in this case I am only interested in the org-protocol case.

My desktop application assigns a name to the frame in which I'm capturing with
org-protocol. We check for that name when toggling ~org-capture-mode~ and if it
matches we kill all other windows, forcing the capture one to take the entire
frame.

#+begin_src emacs-lisp
  (use-feature org
    :config
    (require 'org-protocol)

    (defvar org-protocol-capture-nest-level 0
      "Tracks capture level depth in org-protocol captures.")

    (add-hook 'org-capture-mode-hook
              (lambda ()
                (cl-incf org-protocol-capture-nest-level))
              -99)

    (add-hook 'org-capture-after-finalize-hook
              (lambda ()
                (cl-decf org-protocol-capture-nest-level))
              -99)

    (add-hook 'org-capture-mode-hook
              (lambda ()
                (interactive)
                (let ((frame-name (substring-no-properties
                                   (cdr (assoc 'name (frame-parameters))))))
                  (when (string= frame-name "org-protocol-capture")
                    (delete-other-windows)))))

    (add-hook 'org-capture-after-finalize-hook
              (lambda ()
                (interactive)
                (let ((frame-name (substring-no-properties
                                   (cdr (assoc 'name (frame-parameters))))))
                  (when (string= frame-name "org-protocol-capture")
                    (when (zerop org-protocol-capture-nest-level)
                      (delete-frame)))))))
#+end_src
**** Keybindings
Evil has some keybindings that conflict with org mode. Fix them.
#+BEGIN_SRC emacs-lisp
(defun bvn/org-mode-bindings ()
  (nmap nil "TAB" 'org-cycle))
(add-hook 'org-mode-hook 'bvn/org-mode-bindings)
#+END_SRC
*** TODO org-roam
Using org-roam for note taking.
#+BEGIN_SRC emacs-lisp
  (ensure-package org-roam
    :straight (:files (:defaults "extensions/*"))
    :init 
    (setq org-roam-v2-ack t)
    :demand t
    :hook (after-init . org-roam-db-autosync-mode)
    :custom
    (org-roam-directory "~/.org-roam")
    (org-roam-db-location "~/.org-roam/org-roam.db")
    (org-roam-v2-ack t)
    (org-roam-capture-templates
     '(("d" "default" plain "%?"
        :target (file+head "%<%Y%m%d%H%M%S-%N>.org"
                           "#+title: ${title}\n")
        :unnarrowed t))) ;; Remove the slug from the default file name, to prevent file name changing

    (org-roam-capture-ref-templates
     '(("r" "ref" plain "%?"
        :target (file+head "%<%Y%m%d%H%M%S-%N>.org"
                           "#+title: ${title}")
        :unnarrowed t)))
    :config
    (require 'org-roam-protocol)
    :bind (:map global-map
                (("C-c n n" . org-roam-buffer-toggle)
                 ("C-c n f" . org-roam-node-find)
                 ("C-c n g" . org-roam-graph)
                 ("C-c n d d" . org-roam-dailies-goto-today)
                 ("C-c n d p" . org-roam-dailies-goto-previous-note)
                 ("C-c n d n" . org-roam-dailies-goto-next-note)
                 ("C-c n d y" . org-roam-dailies-goto-yesterday))
                :map org-mode-map
                (("C-c n i" . org-roam-node-insert)
                 ("C-c n I" . org-roam-insert-immediate)
                 ("C-c n n" . org-roam-buffer-toggle)
                 ("C-c n n" . org-roam-buffer-toggle)
                 ("C-c n f" . org-roam-node-find)
                 ("C-c n g" . org-roam-graph)
                 ("C-c n d d" . org-roam-dailies-goto-today)
                 ("C-c n d y" . org-roam-dailies-goto-yesterday))))
#+END_SRC
*** TODO Docker
#+BEGIN_SRC emacs-lisp
(ensure-package dockerfile-mode)

(defun docker/dockerfile-mode-mode ()
  '(("Dockerfile\\'" . dockerfile-mode)))
#+END_SRC
*** TODO Terraform
#+BEGIN_SRC emacs-lisp
(ensure-packages hcl-mode terraform-mode company-terraform)
(use-feature terraform-mode
  :config
  (use-feature company-terraform
    :after company
    :config
    (add-hook 'terraform-mode-hook
              (lambda ()
                (interactive)
                (company-mode t)
                (company/set-backend 'company-terraform)))))
#+END_SRC
*** TODO Ediff-mode
I use Ediff-mode for, well, diffing. One thing I want quite often but that isn't
built-in is to use both sides of a merge conflict in order. The following binds
that to the otherwise not bound ~d~ button.
#+begin_src emacs-lisp
  (defun ediff-copy-both-to-C ()
    (interactive)
    (ediff-copy-diff ediff-current-difference nil 'C nil
                     (concat
                      (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                      (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
  (defun add-d-to-ediff-mode-map () (define-key ediff-mode-map "d" 'ediff-copy-both-to-C))
  (add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map)
#+end_src
** Getting Things Done
I'll be using ~org-mode~ for implementing Getting Things Done. However, I don't
want GTD to intervene with regular ~org-mode~. Therefore, we'll have a few
helpers.

One of the things I want to do is to show what next key to press in order to do
the next thing. For this, I might set up a Hydra, or use which-keys, or...

*** Inbox processing
Currently, the inbox is just a single file. ~$HOME/,gtd/inbox.org~. From this
file, we want to file to a number of other files. For starters, we'll just split
out ~projects.org~.

The binding, right now, is not really Hydra, but that's fine.
#+BEGIN_SRC emacs-lisp
(defun gtd/org-refile ()
  (interactive)
  (setq lexical-binding t)
  (let ((org-refile-targets
         '(
           (nil :maxlevel . 1)
           ("~/.gtd/next.org" :maxlevel . 1)
           ("~/.gtd/projects.org" :maxlevel . 2) ;; active / inactive
           ("~/.gtd/rejected.org" :maxlevel . 1)
           ("~/.gtd/finished.org" :maxlevel . 1)
           ;; ("~/.gtd/backlog.org" :maxlevel . 1)
           )))
    (org-refile))) 

  (nmap org-mode-map ",mr" 'gtd/org-refile)
#+END_SRC
** Everything so far, which isn't a lot
#+BEGIN_SRC emacs-lisp
(nmap nil ",ll" 'eval-last-sexp)
#+END_SRC
*** Move custom to its own file
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file 'noerror)
#+END_SRC
